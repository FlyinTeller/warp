using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.XPath;
using Accord.Math.Optimization;
using Warp.Headers;
using Warp.Tools;
using System.Threading;

namespace Warp
{
    public class Movie : WarpBase
    {
        #region Paths and names

        private string _Path = "";
        public string Path
        {
            get { return _Path; }
            set
            {
                if (value != _Path)
                {
                    _Path = value;
                    OnPropertyChanged();
                }
            }
        }

        public string Name => Helper.PathToNameWithExtension(Path);

        public string RootName => Helper.PathToName(Path);

        public string DirectoryName
        {
            get
            {
                if (Path.Length == 0)
                    return "";

                string Dir = "";
                if (Path.Contains("\\"))
                    Dir = Path.Substring(0, Path.LastIndexOf("\\"));
                else if (Path.Contains("/"))
                    Dir = Path.Substring(0, Path.LastIndexOf("/"));

                if (Dir[Dir.Length - 1] != '\\')
                    Dir += "\\";

                return Dir;
            }
        }

        public string PowerSpectrumDir => DirectoryName + "powerspectrum\\";
        public string AverageDir => DirectoryName + "average\\";
        public string ShiftedStackDir => DirectoryName + "stack\\";
        public string DeconvolvedStackDir => DirectoryName + "deconv\\";
        public string ParticlesDir => DirectoryName + "particles\\";
        public string ParticleTiltsDir => DirectoryName + "particletilts\\";
        public string ParticleCTFDir => DirectoryName + "particlectf\\";
        public string ParticleTiltsCTFDir => DirectoryName + "particletiltsctf\\";
        public string ParticleMoviesDir => DirectoryName + "particlemovies\\";
        public string ParticleMoviesCTFDir => DirectoryName + "particlemoviesctf\\";

        public string PowerSpectrumPath => PowerSpectrumDir + RootName + ".mrc";
        public string AveragePath => AverageDir + RootName + ".mrc";
        public string ShiftedStackPath => ShiftedStackDir + RootName + "_movie.mrcs";
        public string ParticlesPath => ParticlesDir + RootName + "_particles.mrcs";
        public string ParticleCTFPath => ParticleCTFDir + RootName + "_particlesctf.mrcs";
        public string ParticleMoviesPath => ParticleMoviesDir + RootName + "_particlemovies.mrcs";
        public string ParticleMoviesCTFPath => ParticleMoviesCTFDir + RootName + "_particlemoviesctf.mrcs";

        public string XMLName => RootName + ".xml";
        public string XMLPath => DirectoryName + XMLName;

        #endregion

        private bool _UnselectManual = false;
        public bool UnselectManual
        {
            get { return _UnselectManual; }
            set
            {
                if (value != _UnselectManual)
                {
                    _UnselectManual = value;
                    OnPropertyChanged();
                    OnProcessingChanged();
                    SaveMeta();
                }
            }
        }

        private bool _UnselectFilter = false;
        public bool UnselectFilter
        {
            get { return _UnselectFilter; }
            set
            {
                if (value != _UnselectFilter)
                {
                    _UnselectFilter = value;
                    OnPropertyChanged();
                    SaveMeta();
                }
            }
        }

        #region Power spectrum and CTF

        private CTF _CTF = new CTF();
        public CTF CTF
        {
            get { return _CTF; }
            set
            {
                if (value != _CTF)
                {
                    _CTF = value;
                    OnPropertyChanged();
                }
            }
        }
        
        private float2[] _PS1D;
        public float2[] PS1D
        {
            get { return _PS1D; }
            set
            {
                if (value != _PS1D)
                {
                    _PS1D = value;
                    OnPropertyChanged();
                }
            }
        }

        private float2[] _Simulated1D;
        public float2[] Simulated1D
        {
            get { return _Simulated1D ?? (_Simulated1D = GetSimulated1D()); }
            set
            {
                if (value != _Simulated1D)
                {
                    _Simulated1D = value;
                    OnPropertyChanged();
                }
            }
        }

        protected float2[] GetSimulated1D()
        {
            if (PS1D == null || _SimulatedBackground == null)
                return null;

            float[] SimulatedCTF = CTF.Get1D(PS1D.Length, true);

            float2[] Result = new float2[PS1D.Length];
            for (int i = 0; i < Result.Length; i++)
                Result[i] = new float2(PS1D[i].X, _SimulatedBackground.Interp(PS1D[i].X) + SimulatedCTF[i] * _SimulatedScale.Interp(PS1D[i].X));

            return Result;
        }

        private Cubic1D _SimulatedBackground;
        public Cubic1D SimulatedBackground
        {
            get { return _SimulatedBackground; }
            set
            {
                if (value != _SimulatedBackground)
                {
                    _SimulatedBackground = value;
                    OnPropertyChanged();
                }
            }
        }

        private Cubic1D _SimulatedScale = new Cubic1D(new[] { new float2(0, 1), new float2(1, 1) });
        public Cubic1D SimulatedScale
        {
            get { return _SimulatedScale; }
            set
            {
                if (value != _SimulatedScale)
                {
                    _SimulatedScale = value;
                    OnPropertyChanged();
                }
            }
        }

        private decimal _CTFResolutionEstimate = 0;
        public decimal CTFResolutionEstimate
        {
            get { return _CTFResolutionEstimate; }
            set { if (value != _CTFResolutionEstimate) { _CTFResolutionEstimate = value; OnPropertyChanged(); } }
        }

        #endregion

        #region Movement

        private decimal _MeanFrameMovement = 0;
        public decimal MeanFrameMovement
        {
            get { return _MeanFrameMovement; }
            set { if (value != _MeanFrameMovement) { _MeanFrameMovement = value; OnPropertyChanged(); } }
        }

        #endregion

        #region Grids

        private CubicGrid _GridCTF = new CubicGrid(new int3(1));
        public CubicGrid GridCTF
        {
            get { return _GridCTF; }
            set
            {
                if (value != _GridCTF)
                {
                    _GridCTF = value;
                    OnPropertyChanged();
                }
            }
        }

        private CubicGrid _GridCTFPhase = new CubicGrid(new int3(1));
        public CubicGrid GridCTFPhase
        {
            get { return _GridCTFPhase; }
            set
            {
                if (value != _GridCTFPhase)
                {
                    _GridCTFPhase = value;
                    OnPropertyChanged();
                }
            }
        }

        private CubicGrid _GridMovementX = new CubicGrid(new int3(1));
        public CubicGrid GridMovementX
        {
            get { return _GridMovementX; }
            set
            {
                if (value != _GridMovementX)
                {
                    _GridMovementX = value;
                    OnPropertyChanged();
                }
            }
        }

        private CubicGrid _GridMovementY = new CubicGrid(new int3(1));
        public CubicGrid GridMovementY
        {
            get { return _GridMovementY; }
            set
            {
                if (value != _GridMovementY)
                {
                    _GridMovementY = value;
                    OnPropertyChanged();
                }
            }
        }

        private CubicGrid _GridLocalX = new CubicGrid(new int3(1));
        public CubicGrid GridLocalX
        {
            get { return _GridLocalX; }
            set
            {
                if (value != _GridLocalX)
                {
                    _GridLocalX = value;
                    OnPropertyChanged();
                }
            }
        }

        private CubicGrid _GridLocalY = new CubicGrid(new int3(1));
        public CubicGrid GridLocalY
        {
            get { return _GridLocalY; }
            set
            {
                if (value != _GridLocalY)
                {
                    _GridLocalY = value;
                    OnPropertyChanged();
                }
            }
        }

        private List<CubicGrid> _PyramidShiftX = new List<CubicGrid>();
        public List<CubicGrid> PyramidShiftX
        {
            get { return _PyramidShiftX; }
            set
            {
                if (value != _PyramidShiftX)
                {
                    _PyramidShiftX = value;
                    OnPropertyChanged();
                }
            }
        }

        private List<CubicGrid> _PyramidShiftY = new List<CubicGrid>();
        public List<CubicGrid> PyramidShiftY
        {
            get { return _PyramidShiftY; }
            set
            {
                if (value != _PyramidShiftY)
                {
                    _PyramidShiftY = value;
                    OnPropertyChanged();
                }
            }
        }

        #endregion

        #region Processing options

        private bool _IsProcessing = false;
        public bool IsProcessing
        {
            get { return _IsProcessing; }
            set
            {
                if (value != _IsProcessing)
                {
                    _IsProcessing = value;
                    if (value)
                        OnProcessingStarted();
                    else
                        OnProcessingFinished();
                    OnPropertyChanged();
                }
            }
        }

        private ProcessingOptionsMovieCTF _OptionsCTF = null;
        public ProcessingOptionsMovieCTF OptionsCTF
        {
            get { return _OptionsCTF; }
            set
            {
                if (value != _OptionsCTF)
                {
                    _OptionsCTF = value;
                    OnPropertyChanged();
                    OnProcessingChanged();
                    OnCTF1DChanged();
                    OnCTF2DChanged();
                    OnPS2DChanged();
                }
            }
        }

        private ProcessingOptionsMovieMovement _OptionsMovement = null;
        public ProcessingOptionsMovieMovement OptionsMovement
        {
            get { return _OptionsMovement; }
            set
            {
                if (value != _OptionsMovement)
                {
                    _OptionsMovement = value;
                    OnPropertyChanged();
                    OnProcessingChanged();
                    OnMovementChanged();
                }
            }
        }

        private ProcessingOptionsMovieExport _OptionsMovieExport = null;
        public ProcessingOptionsMovieExport OptionsMovieExport
        {
            get { return _OptionsMovieExport; }
            set
            {
                if (value != _OptionsMovieExport)
                {
                    _OptionsMovieExport = value;
                    OnPropertyChanged();
                    OnProcessingChanged();
                    OnAverageChanged();
                }
            }
        }

        public bool AreOptionsConflicted()
        {
            bool Result = false;

            if (OptionsCTF != null && OptionsMovement != null)
                Result |= OptionsCTF != OptionsMovement;
            if (OptionsCTF != null && OptionsMovieExport != null)
                Result |= OptionsCTF != OptionsMovieExport;
            if (OptionsMovement != null && OptionsMovieExport != null)
                Result |= OptionsMovement != OptionsMovieExport;

            return Result;
        }

        #endregion

        #region Events

        public event EventHandler ProcessingStarted;
        private void OnProcessingStarted() => ProcessingStarted?.Invoke(this, null);

        public event EventHandler ProcessingChanged;
        private void OnProcessingChanged() => ProcessingChanged?.Invoke(this, null);

        public event EventHandler ProcessingFinished;
        private void OnProcessingFinished() => ProcessingFinished?.Invoke(this, null);

        public event EventHandler CTF1DChanged;
        private void OnCTF1DChanged() => CTF1DChanged?.Invoke(this, null);

        public event EventHandler CTF2DChanged;
        private void OnCTF2DChanged() => CTF2DChanged?.Invoke(this, null);

        public event EventHandler PS2DChanged;
        private void OnPS2DChanged() => PS2DChanged?.Invoke(this, null);

        public event EventHandler MovementChanged;
        private void OnMovementChanged() => MovementChanged?.Invoke(this, null);

        public event EventHandler AverageChanged;
        private void OnAverageChanged() => AverageChanged?.Invoke(this, null);
        
        #endregion

        public Movie(string path)
        {
            Path = path;

            LoadMeta();
        }

        public virtual void LoadMeta()
        {
            if (!File.Exists(XMLPath))
                return;

            using (Stream SettingsStream = File.OpenRead(XMLPath))
            {
                XPathDocument Doc = new XPathDocument(SettingsStream);
                XPathNavigator Reader = Doc.CreateNavigator();
                Reader.MoveToRoot();
                Reader.MoveToFirstChild();

                UnselectFilter = XMLHelper.LoadAttribute(Reader, "UnselectFilter", UnselectFilter);
                UnselectManual = XMLHelper.LoadAttribute(Reader, "UnselectManual", UnselectManual);
                CTFResolutionEstimate = XMLHelper.LoadAttribute(Reader, "CTFResolutionEstimate", CTFResolutionEstimate);
                MeanFrameMovement = XMLHelper.LoadAttribute(Reader, "MeanFrameMovement", MeanFrameMovement);

                XPathNavigator NavPS1D = Reader.SelectSingleNode("//PS1D");
                if (NavPS1D != null)
                    PS1D = NavPS1D.InnerXml.Split(';').Select(v =>
                    {
                        string[] Pair = v.Split('|');
                        return new float2(float.Parse(Pair[0], CultureInfo.InvariantCulture), float.Parse(Pair[1], CultureInfo.InvariantCulture));
                    }).ToArray();

                XPathNavigator NavSimBackground = Reader.SelectSingleNode("//SimulatedBackground");
                if (NavSimBackground != null)
                    _SimulatedBackground = new Cubic1D(NavSimBackground.InnerXml.Split(';').Select(v =>
                    {
                        string[] Pair = v.Split('|');
                        return new float2(float.Parse(Pair[0], CultureInfo.InvariantCulture), float.Parse(Pair[1], CultureInfo.InvariantCulture));
                    }).ToArray());

                XPathNavigator NavSimScale = Reader.SelectSingleNode("//SimulatedScale");
                if (NavSimScale != null)
                    _SimulatedScale = new Cubic1D(NavSimScale.InnerXml.Split(';').Select(v =>
                    {
                        string[] Pair = v.Split('|');
                        return new float2(float.Parse(Pair[0], CultureInfo.InvariantCulture), float.Parse(Pair[1], CultureInfo.InvariantCulture));
                    }).ToArray());

                XPathNavigator NavCTF = Reader.SelectSingleNode("//CTF");
                if (NavCTF != null)
                    CTF.ReadFromXML(NavCTF);

                XPathNavigator NavGridCTF = Reader.SelectSingleNode("//GridCTF");
                if (NavGridCTF != null)
                    GridCTF = CubicGrid.Load(NavGridCTF);

                XPathNavigator NavGridCTFPhase = Reader.SelectSingleNode("//GridCTFPhase");
                if (NavGridCTFPhase != null)
                    GridCTFPhase = CubicGrid.Load(NavGridCTFPhase);

                XPathNavigator NavMoveX = Reader.SelectSingleNode("//GridMovementX");
                if (NavMoveX != null)
                    GridMovementX = CubicGrid.Load(NavMoveX);

                XPathNavigator NavMoveY = Reader.SelectSingleNode("//GridMovementY");
                if (NavMoveY != null)
                    GridMovementY = CubicGrid.Load(NavMoveY);

                XPathNavigator NavLocalX = Reader.SelectSingleNode("//GridLocalMovementX");
                if (NavLocalX != null)
                    GridLocalX = CubicGrid.Load(NavLocalX);

                XPathNavigator NavLocalY = Reader.SelectSingleNode("//GridLocalMovementY");
                if (NavLocalY != null)
                    GridLocalY = CubicGrid.Load(NavLocalY);

                PyramidShiftX.Clear();
                foreach (XPathNavigator NavShiftX in Reader.Select("//PyramidShiftX"))
                    PyramidShiftX.Add(CubicGrid.Load(NavShiftX));

                PyramidShiftY.Clear();
                foreach (XPathNavigator NavShiftY in Reader.Select("//PyramidShiftY"))
                    PyramidShiftY.Add(CubicGrid.Load(NavShiftY));

                XPathNavigator NavOptionsCTF = Reader.SelectSingleNode("//OptionsCTF");
                if (NavOptionsCTF != null)
                {
                    ProcessingOptionsMovieCTF Temp = new ProcessingOptionsMovieCTF();
                    Temp.ReadFromXML(NavOptionsCTF);
                    OptionsCTF = Temp;
                }

                XPathNavigator NavOptionsMovement = Reader.SelectSingleNode("//OptionsMovement");
                if (NavOptionsMovement != null)
                {
                    ProcessingOptionsMovieMovement Temp = new ProcessingOptionsMovieMovement();
                    Temp.ReadFromXML(NavOptionsMovement);
                    OptionsMovement = Temp;
                }

                XPathNavigator NavOptionsExport = Reader.SelectSingleNode("//OptionsMovieExport");
                if (NavOptionsExport != null)
                {
                    ProcessingOptionsMovieExport Temp = new ProcessingOptionsMovieExport();
                    Temp.ReadFromXML(NavOptionsExport);
                    OptionsMovieExport = Temp;
                }
            }
        }

        public virtual void SaveMeta()
        {
            using (XmlTextWriter Writer = new XmlTextWriter(XMLPath, Encoding.Unicode))
            {
                Writer.Formatting = Formatting.Indented;
                Writer.IndentChar = '\t';
                Writer.Indentation = 1;
                Writer.WriteStartDocument();
                Writer.WriteStartElement("Movie");

                Writer.WriteAttributeString("UnselectFilter", UnselectFilter.ToString());
                Writer.WriteAttributeString("UnselectManual", UnselectManual.ToString());
                Writer.WriteAttributeString("CTFResolutionEstimate", CTFResolutionEstimate.ToString(CultureInfo.InvariantCulture));
                Writer.WriteAttributeString("MeanFrameMovement", MeanFrameMovement.ToString(CultureInfo.InvariantCulture));

                if (OptionsCTF != null)
                {
                    Writer.WriteStartElement("OptionsCTF");
                    OptionsCTF.WriteToXML(Writer);
                    Writer.WriteEndElement();
                }

                if (PS1D != null)
                {
                    Writer.WriteStartElement("PS1D");
                    Writer.WriteString(string.Join(";", PS1D.Select(v => v.X.ToString(CultureInfo.InvariantCulture) + "|" + v.Y.ToString(CultureInfo.InvariantCulture))));
                    Writer.WriteEndElement();
                }

                if (SimulatedBackground != null)
                {
                    Writer.WriteStartElement("SimulatedBackground");
                    Writer.WriteString(string.Join(";",
                                                   _SimulatedBackground.Data.Select(v => v.X.ToString(CultureInfo.InvariantCulture) +
                                                                                         "|" +
                                                                                         v.Y.ToString(CultureInfo.InvariantCulture))));
                    Writer.WriteEndElement();
                }

                if (SimulatedScale != null)
                {
                    Writer.WriteStartElement("SimulatedScale");
                    Writer.WriteString(string.Join(";",
                                                   _SimulatedScale.Data.Select(v => v.X.ToString(CultureInfo.InvariantCulture) +
                                                                                    "|" +
                                                                                    v.Y.ToString(CultureInfo.InvariantCulture))));
                    Writer.WriteEndElement();
                }

                Writer.WriteStartElement("CTF");
                CTF.WriteToXML(Writer);
                Writer.WriteEndElement();

                Writer.WriteStartElement("GridCTF");
                GridCTF.Save(Writer);
                Writer.WriteEndElement();

                Writer.WriteStartElement("GridCTFPhase");
                GridCTFPhase.Save(Writer);
                Writer.WriteEndElement();

                if (OptionsMovement != null)
                {
                    Writer.WriteStartElement("OptionsMovement");
                    OptionsMovement.WriteToXML(Writer);
                    Writer.WriteEndElement();
                }

                Writer.WriteStartElement("GridMovementX");
                GridMovementX.Save(Writer);
                Writer.WriteEndElement();

                Writer.WriteStartElement("GridMovementY");
                GridMovementY.Save(Writer);
                Writer.WriteEndElement();

                Writer.WriteStartElement("GridLocalMovementX");
                GridLocalX.Save(Writer);
                Writer.WriteEndElement();

                Writer.WriteStartElement("GridLocalMovementY");
                GridLocalY.Save(Writer);
                Writer.WriteEndElement();

                foreach (var grid in PyramidShiftX)
                {
                    Writer.WriteStartElement("PyramidShiftX");
                    grid.Save(Writer);
                    Writer.WriteEndElement();
                }

                foreach (var grid in PyramidShiftY)
                {
                    Writer.WriteStartElement("PyramidShiftY");
                    grid.Save(Writer);
                    Writer.WriteEndElement();
                }

                if (OptionsMovieExport != null)
                {
                    Writer.WriteStartElement("OptionsMovieExport");
                    OptionsMovieExport.WriteToXML(Writer);
                    Writer.WriteEndElement();
                }

                Writer.WriteEndElement();
                Writer.WriteEndDocument();
            }
        }

        public virtual void ProcessCTF(Image originalStack, ProcessingOptionsMovieCTF options)
        {
            IsProcessing = true;

            if (!Directory.Exists(PowerSpectrumDir))
                Directory.CreateDirectory(PowerSpectrumDir);

            //CTF = new CTF();
            PS1D = null;
            _SimulatedBackground = null;
            _SimulatedScale = new Cubic1D(new[] { new float2(0, 1), new float2(1, 1) });

            #region Dimensions and grids

            int NFrames = originalStack.Dims.Z;
            int2 DimsImage = new int2(originalStack.Dims);
            int2 DimsRegion = new int2(options.Window);

            float OverlapFraction = 0.5f;
            int2 DimsPositionGrid;
            int3[] PositionGrid = Helper.GetEqualGridSpacing(DimsImage, new int2(DimsRegion.X / 1, DimsRegion.Y / 1), OverlapFraction, out DimsPositionGrid);
            int NPositions = (int)DimsPositionGrid.Elements();

            int CTFGridX = Math.Min(DimsPositionGrid.X, options.GridDims.X);
            int CTFGridY = Math.Min(DimsPositionGrid.Y, options.GridDims.Y);
            int CTFGridZ = Math.Min(NFrames, options.GridDims.Z);
            GridCTF = new CubicGrid(new int3(CTFGridX, CTFGridY, CTFGridZ));
            GridCTFPhase = new CubicGrid(new int3(1, 1, CTFGridZ));

            bool CTFSpace = CTFGridX * CTFGridY > 1;
            bool CTFTime = CTFGridZ > 1;
            int3 CTFSpectraGrid = new int3(CTFSpace ? DimsPositionGrid.X : 1,
                                           CTFSpace ? DimsPositionGrid.Y : 1,
                                           CTFTime ? CTFGridZ : 1);

            int MinFreqInclusive = (int)(options.RangeMin * DimsRegion.X / 2);
            int MaxFreqExclusive = (int)(options.RangeMax * DimsRegion.X / 2);
            int NFreq = MaxFreqExclusive - MinFreqInclusive;

            #endregion

            #region Allocate GPU memory

            Image CTFSpectra = new Image(IntPtr.Zero, new int3(DimsRegion.X, DimsRegion.X, (int)CTFSpectraGrid.Elements()), true);
            Image CTFMean = new Image(IntPtr.Zero, new int3(DimsRegion), true);
            Image CTFCoordsCart = new Image(new int3(DimsRegion), true, true);
            Image CTFCoordsPolarTrimmed = new Image(new int3(NFreq, DimsRegion.X, 1), false, true);

            #endregion

            // Extract movie regions, create individual spectra in Cartesian coordinates and their mean.

            #region Create spectra

            GPU.CreateSpectra(originalStack.GetDevice(Intent.Read),
                              DimsImage,
                              NFrames,
                              PositionGrid,
                              NPositions,
                              DimsRegion,
                              CTFSpectraGrid,
                              CTFSpectra.GetDevice(Intent.Write),
                              CTFMean.GetDevice(Intent.Write));
            originalStack.FreeDevice(); // Won't need it in this method anymore.

            #endregion

            // Populate address arrays for later.

            #region Init addresses

            {
                float2[] CoordsData = new float2[CTFCoordsCart.ElementsSliceComplex];

                Helper.ForEachElementFT(DimsRegion, (x, y, xx, yy, r, a) => CoordsData[y * (DimsRegion.X / 2 + 1) + x] = new float2(r, a));
                CTFCoordsCart.UpdateHostWithComplex(new[] { CoordsData });

                CoordsData = new float2[NFreq * DimsRegion.X];
                Helper.ForEachElement(CTFCoordsPolarTrimmed.DimsSlice, (x, y) =>
                {
                    float Angle = ((float)y / DimsRegion.X + 0.5f) * (float)Math.PI;
                    float Ny = 1f / DimsRegion.X;
                    CoordsData[y * NFreq + x] = new float2((x + MinFreqInclusive) * Ny, Angle);
                });
                CTFCoordsPolarTrimmed.UpdateHostWithComplex(new[] { CoordsData });
            }

            #endregion

            // Retrieve average 1D spectrum from CTFMean (not corrected for astigmatism yet).

            #region Initial 1D spectrum

            {
                Image CTFAverage1D = new Image(IntPtr.Zero, new int3(DimsRegion.X / 2, 1, 1));

                GPU.CTFMakeAverage(CTFMean.GetDevice(Intent.Read),
                                   CTFCoordsCart.GetDevice(Intent.Read),
                                   (uint)CTFMean.ElementsSliceReal,
                                   (uint)DimsRegion.X,
                                   new[] { new CTF().ToStruct() },
                                   new CTF().ToStruct(),
                                   0,
                                   (uint)DimsRegion.X / 2,
                                   null,
                                   1,
                                   CTFAverage1D.GetDevice(Intent.Write));

                //CTFAverage1D.WriteMRC("CTFAverage1D.mrc");

                float[] CTFAverage1DData = CTFAverage1D.GetHost(Intent.Read)[0];
                float2[] ForPS1D = new float2[DimsRegion.X / 2];
                for (int i = 0; i < ForPS1D.Length; i++)
                    ForPS1D[i] = new float2((float)i / DimsRegion.X, (float)Math.Round(CTFAverage1DData[i], 4));
                _PS1D = ForPS1D;

                CTFAverage1D.Dispose();
            }

            #endregion

            #region Background fitting methods

            Action UpdateBackgroundFit = () =>
            {
                float2[] ForPS1D = PS1D.Skip(Math.Max(5, MinFreqInclusive / 2)).ToArray();
                Cubic1D.FitCTF(ForPS1D,
                               v => v.Select(x => CTF.Get1D(x / (float)CTF.PixelSize, true)).ToArray(),
                               CTF.GetZeros(),
                               CTF.GetPeaks(),
                               out _SimulatedBackground,
                               out _SimulatedScale);
            };

            Action<bool> UpdateRotationalAverage = keepbackground =>
            {
                float[] MeanData = CTFMean.GetHost(Intent.Read)[0];

                Image CTFMeanCorrected = new Image(new int3(DimsRegion), true);
                float[] MeanCorrectedData = CTFMeanCorrected.GetHost(Intent.Write)[0];

                // Subtract current background estimate from spectra, populate coords.
                Helper.ForEachElementFT(DimsRegion,
                                        (x, y, xx, yy, r, a) =>
                                        {
                                            int i = y * (DimsRegion.X / 2 + 1) + x;
                                            MeanCorrectedData[i] = MeanData[i] - _SimulatedBackground.Interp(r / DimsRegion.X);
                                        });

                Image CTFAverage1D = new Image(IntPtr.Zero, new int3(DimsRegion.X / 2, 1, 1));

                GPU.CTFMakeAverage(CTFMeanCorrected.GetDevice(Intent.Read),
                                   CTFCoordsCart.GetDevice(Intent.Read),
                                   (uint)CTFMeanCorrected.DimsEffective.ElementsSlice(),
                                   (uint)DimsRegion.X,
                                   new[] { CTF.ToStruct() },
                                   CTF.ToStruct(),
                                   0,
                                   (uint)DimsRegion.X / 2,
                                   null,
                                   1,
                                   CTFAverage1D.GetDevice(Intent.Write));

                //CTFAverage1D.WriteMRC("CTFAverage1D.mrc");

                float[] RotationalAverageData = CTFAverage1D.GetHost(Intent.Read)[0];
                float2[] ForPS1D = new float2[PS1D.Length];
                if (keepbackground)
                    for (int i = 0; i < ForPS1D.Length; i++)
                        ForPS1D[i] = new float2((float)i / DimsRegion.X, RotationalAverageData[i] + _SimulatedBackground.Interp((float)i / DimsRegion.X));
                else
                    for (int i = 0; i < ForPS1D.Length; i++)
                        ForPS1D[i] = new float2((float)i / DimsRegion.X, RotationalAverageData[i]);
                MathHelper.UnNaN(ForPS1D);

                _PS1D = ForPS1D;

                CTFMeanCorrected.Dispose();
                CTFAverage1D.Dispose();
            };

            #endregion

            // Fit background to currently best average (not corrected for astigmatism yet).
            {
                float2[] ForPS1D = PS1D.Skip(MinFreqInclusive).Take(Math.Max(2, NFreq / 2)).ToArray();

                int NumNodes = Math.Max(3, (int)((options.RangeMax - options.RangeMin) * 5M));
                _SimulatedBackground = Cubic1D.Fit(ForPS1D, NumNodes); // This won't fit falloff and scale, because approx function is 0

                float[] CurrentBackground = _SimulatedBackground.Interp(PS1D.Select(p => p.X).ToArray()).Skip(MinFreqInclusive).Take(NFreq / 2).ToArray();
                float[] Subtracted1D = new float[ForPS1D.Length];
                for (int i = 0; i < ForPS1D.Length; i++)
                    Subtracted1D[i] = ForPS1D[i].Y - CurrentBackground[i];
                MathHelper.NormalizeInPlace(Subtracted1D);

                float ZMin = (float)options.ZMin;
                float ZMax = (float)options.ZMax;
                float ZStep = (ZMax - ZMin) / 200f;

                float BestZ = 0, BestPhase = 0, BestScore = -float.MaxValue;
                for (float z = ZMin; z <= ZMax + 1e-5f; z += ZStep)
                {
                    for (float p = 0; p <= (options.DoPhase ? 1f : 0f); p += 0.01f)
                    {
                        CTF CurrentParams = new CTF
                        {
                            PixelSize = options.BinnedPixelSizeMean,

                            Defocus = (decimal)z,
                            PhaseShift = (decimal)p,

                            Cs = options.Cs,
                            Voltage = options.Voltage,
                            Amplitude = options.Amplitude
                        };
                        float[] SimulatedCTF = CurrentParams.Get1D(PS1D.Length, true).Skip(MinFreqInclusive).Take(Math.Max(2, NFreq / 2)).ToArray();
                        MathHelper.NormalizeInPlace(SimulatedCTF);
                        float Score = MathHelper.CrossCorrelate(Subtracted1D, SimulatedCTF);
                        if (Score > BestScore)
                        {
                            BestScore = Score;
                            BestZ = z;
                            BestPhase = p;
                        }
                    }
                }

                CTF = new CTF
                {
                    PixelSize = options.BinnedPixelSizeMean,

                    Defocus = (decimal)BestZ,
                    PhaseShift = (decimal)BestPhase,

                    Cs = options.Cs,
                    Voltage = options.Voltage,
                    Amplitude = options.Amplitude
                };

                UpdateRotationalAverage(true); // This doesn't have a nice background yet.
                UpdateBackgroundFit(); // Now get a reasonably nice background.
            }

            

            // Fit defocus, (phase shift), (astigmatism) to average background-subtracted spectrum, 
            // which is in polar coords at this point (for equal weighting of all frequencies).

            #region Grid search

            {
                Image CTFMeanPolarTrimmed = CTFMean.AsPolar((uint)MinFreqInclusive, (uint)(MinFreqInclusive + NFreq / 1));

                // Subtract current background.
                Image CurrentBackground = new Image(_SimulatedBackground.Interp(PS1D.Select(p => p.X).ToArray()).Skip(MinFreqInclusive).Take(NFreq / 1).ToArray());
                CTFMeanPolarTrimmed.SubtractFromLines(CurrentBackground);
                CurrentBackground.Dispose();

                /*Image WaterMask = new Image(new int3(NFreq, 1, 1));
                float[] WaterData = WaterMask.GetHost(Intent.Write)[0];
                for (int i = 0; i < NFreq; i++)
                {
                    float f = (i + MinFreqInclusive) / (float)DimsRegion.X * 2f;
                    WaterData[i] = f > 0.2f && f < 0.6f ? 0f : 1f;
                }
                //CTFMeanPolarTrimmed.MultiplyLines(WaterMask);
                WaterMask.Dispose();*/

                // Normalize for CC (not strictly needed, but it's converted for fp16 later, so let's be on the safe side of the fp16 range.
                GPU.Normalize(CTFMeanPolarTrimmed.GetDevice(Intent.Read), CTFMeanPolarTrimmed.GetDevice(Intent.Write), (uint)CTFMeanPolarTrimmed.ElementsReal, 1);
                //CTFMeanPolarTrimmed.WriteMRC("ctfmeanpolartrimmed.mrc");

                CTF StartParams = new CTF
                {
                    PixelSize = options.BinnedPixelSizeMean,
                    PixelSizeDelta = options.BinnedPixelSizeDelta,
                    PixelSizeAngle = options.PixelSizeAngle,

                    Defocus = CTF.Defocus,// (MainWindow.Options.CTFZMin + MainWindow.Options.CTFZMax) * 0.5M,
                    DefocusDelta = options.Astigmatism,
                    DefocusAngle = options.AstigmatismAngle,

                    Cs = options.Cs,
                    Voltage = options.Voltage,
                    Amplitude = options.Amplitude
                };

                CTFFitStruct FitParams = new CTFFitStruct
                {
                    //Pixelsize = new float3(-0.02e-10f, 0.02e-10f, 0.01e-10f),
                    //Pixeldelta = new float3(0.0f, 0.02e-10f, 0.01e-10f),
                    //Pixelangle = new float3(0, 2 * (float)Math.PI, 1 * (float)Math.PI / 18),

                    //Defocus = new float3((float)(MainWindow.Options.CTFZMin - StartParams.Defocus) * 1e-6f,
                    //                     (float)(MainWindow.Options.CTFZMax - StartParams.Defocus) * 1e-6f,
                    //                     0.025e-6f),
                    Defocus = new float3(-0.2e-6f,
                                         0.2e-6f,
                                         0.04e-6f),

                    Defocusdelta = options.Astigmatism == 0M ? new float3(0, 0.2e-6f, 0.04e-6f) : new float3(0, 0, 0),
                    Astigmatismangle = options.Astigmatism == 0M ? new float3(0, 1 * (float)Math.PI, 1 * (float)Math.PI / 10) : new float3(0, 0, 0),
                    Phaseshift = options.DoPhase ? new float3(0, (float)Math.PI, 0.025f * (float)Math.PI) : new float3(0, 0, 0)
                };

                CTFStruct ResultStruct = GPU.CTFFitMean(CTFMeanPolarTrimmed.GetDevice(Intent.Read),
                                                        CTFCoordsPolarTrimmed.GetDevice(Intent.Read),
                                                        CTFMeanPolarTrimmed.DimsSlice,
                                                        StartParams.ToStruct(),
                                                        FitParams,
                                                        options.Astigmatism == 0M);
                CTF.FromStruct(ResultStruct);
                CTF.Defocus = Math.Max(CTF.Defocus, options.ZMin);

                CTFMeanPolarTrimmed.Dispose();

                UpdateRotationalAverage(true); // This doesn't have a nice background yet.
                UpdateBackgroundFit(); // Now get a reasonably nice background.

                UpdateRotationalAverage(true); // This time, with the nice background.
                UpdateBackgroundFit(); // Make the background even nicer!
            }

            #endregion

            // Do BFGS optimization of defocus, astigmatism and phase shift,
            // using 2D simulation for comparison

            #region BFGS

            bool[] CTFSpectraConsider = new bool[CTFSpectraGrid.Elements()];
            for (int i = 0; i < CTFSpectraConsider.Length; i++)
                CTFSpectraConsider[i] = true;
            int NCTFSpectraConsider = CTFSpectraConsider.Length;

            GridCTF = new CubicGrid(GridCTF.Dimensions, (float)CTF.Defocus, (float)CTF.Defocus, Dimension.X);
            GridCTFPhase = new CubicGrid(GridCTFPhase.Dimensions, (float)CTF.PhaseShift, (float)CTF.PhaseShift, Dimension.X);

            for (int preciseFit = 2; preciseFit < 3; preciseFit++)
            {
                NFreq = (MaxFreqExclusive - MinFreqInclusive) * (preciseFit + 1) / 3;

                Image CTFSpectraPolarTrimmed = CTFSpectra.AsPolar((uint)MinFreqInclusive, (uint)(MinFreqInclusive + NFreq));
                CTFSpectra.FreeDevice(); // This will only be needed again for the final PS1D.

                #region Create background and scale

                float[] CurrentScale = _SimulatedScale.Interp(PS1D.Select(p => p.X).ToArray());

                Image CTFSpectraScale = new Image(new int3(NFreq, DimsRegion.X, 1));
                float[] CTFSpectraScaleData = CTFSpectraScale.GetHost(Intent.Write)[0];

                // Trim polar to relevant frequencies, and populate coordinates.
                Parallel.For(0, DimsRegion.X, y =>
                {
                    float Angle = ((float)y / DimsRegion.X + 0.5f) * (float)Math.PI;
                    for (int x = 0; x < NFreq; x++)
                        CTFSpectraScaleData[y * NFreq + x] = CurrentScale[x + MinFreqInclusive];
                });
                //CTFSpectraScale.WriteMRC("ctfspectrascale.mrc");

                // Background is just 1 line since we're in polar.
                Image CurrentBackground = new Image(_SimulatedBackground.Interp(PS1D.Select(p => p.X).ToArray()).Skip(MinFreqInclusive).Take(NFreq).ToArray());

                #endregion

                CTFSpectraPolarTrimmed.SubtractFromLines(CurrentBackground);
                CurrentBackground.Dispose();

                // Normalize background-subtracted spectra.
                GPU.Normalize(CTFSpectraPolarTrimmed.GetDevice(Intent.Read),
                              CTFSpectraPolarTrimmed.GetDevice(Intent.Write),
                              (uint)CTFSpectraPolarTrimmed.ElementsSliceReal,
                              (uint)CTFSpectraGrid.Elements());
                //CTFSpectraPolarTrimmed.WriteMRC("ctfspectrapolartrimmed.mrc");

                #region Convert to fp16

                Image CTFSpectraPolarTrimmedHalf = CTFSpectraPolarTrimmed.AsHalf();
                CTFSpectraPolarTrimmed.Dispose();

                Image CTFSpectraScaleHalf = CTFSpectraScale.AsHalf();
                CTFSpectraScale.Dispose();
                Image CTFCoordsPolarTrimmedHalf = CTFCoordsPolarTrimmed.AsHalf();

                #endregion

                // Wiggle weights show how the defocus on the spectra grid is altered 
                // by changes in individual anchor points of the spline grid.
                // They are used later to compute the dScore/dDefocus values for each spectrum 
                // only once, and derive the values for each anchor point from them.
                float[][] WiggleWeights = GridCTF.GetWiggleWeights(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, 1f / (CTFGridZ + 1)));
                float[][] WiggleWeightsPhase = GridCTFPhase.GetWiggleWeights(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, 1f / (CTFGridZ + 1)));

                // Helper method for getting CTFStructs for the entire spectra grid.
                Func<double[], CTF, float[], float[], CTFStruct[]> EvalGetCTF = (input, ctf, defocusValues, phaseValues) =>
                {
                    decimal AlteredDelta = (decimal)input[input.Length - 2];
                    decimal AlteredAngle = (decimal)(input[input.Length - 1] * 20 * Helper.ToDeg);

                    CTF Local = ctf.GetCopy();
                    Local.DefocusDelta = AlteredDelta;
                    Local.DefocusAngle = AlteredAngle;

                    CTFStruct LocalStruct = Local.ToStruct();
                    CTFStruct[] LocalParams = new CTFStruct[defocusValues.Length];
                    for (int i = 0; i < LocalParams.Length; i++)
                    {
                        LocalParams[i] = LocalStruct;
                        LocalParams[i].Defocus = defocusValues[i] * -1e-6f;
                        LocalParams[i].PhaseShift = phaseValues[i] * (float)Math.PI;
                    }

                    return LocalParams;
                };

                // Simulate with adjusted CTF, compare to originals

                #region Eval and Gradient methods

                float BorderZ = 0.5f / CTFGridZ;

                Func<double[], double> Eval = input =>
                {
                    CubicGrid Altered = new CubicGrid(GridCTF.Dimensions, input.Take((int)GridCTF.Dimensions.Elements()).Select(v => (float)v).ToArray());
                    float[] DefocusValues = Altered.GetInterpolatedNative(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, BorderZ));
                    CubicGrid AlteredPhase = new CubicGrid(GridCTFPhase.Dimensions, input.Skip((int)GridCTF.Dimensions.Elements()).Take((int)GridCTFPhase.Dimensions.Elements()).Select(v => (float)v).ToArray());
                    float[] PhaseValues = AlteredPhase.GetInterpolatedNative(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, BorderZ));

                    CTFStruct[] LocalParams = EvalGetCTF(input, CTF, DefocusValues, PhaseValues);

                    float[] Result = new float[LocalParams.Length];

                    GPU.CTFCompareToSim(CTFSpectraPolarTrimmedHalf.GetDevice(Intent.Read),
                                        CTFCoordsPolarTrimmedHalf.GetDevice(Intent.Read),
                                        CTFSpectraScaleHalf.GetDevice(Intent.Read),
                                        (uint)CTFSpectraPolarTrimmedHalf.ElementsSliceReal,
                                        LocalParams,
                                        Result,
                                        (uint)LocalParams.Length);

                    float Score = 0;
                    for (int i = 0; i < Result.Length; i++)
                        if (CTFSpectraConsider[i])
                            Score += Result[i];

                    Score /= NCTFSpectraConsider;

                    if (float.IsNaN(Score) || float.IsInfinity(Score))
                        throw new Exception("Bad score.");

                    return 1.0 - Score;
                };

                Func<double[], double[]> Gradient = input =>
                {
                    const float Step = 0.005f;
                    double[] Result = new double[input.Length];

                    // In 0D grid case, just get gradient for all 4 parameters.
                    // In 1+D grid case, do simple gradient for astigmatism and phase, ...
                    int StartComponent = input.Length - 2;
                    //int StartComponent = 0;
                    for (int i = StartComponent; i < input.Length; i++)
                    {
                        double[] UpperInput = new double[input.Length];
                        input.CopyTo(UpperInput, 0);
                        UpperInput[i] += Step;
                        double UpperValue = Eval(UpperInput);

                        double[] LowerInput = new double[input.Length];
                        input.CopyTo(LowerInput, 0);
                        LowerInput[i] -= Step;
                        double LowerValue = Eval(LowerInput);

                        Result[i] = (UpperValue - LowerValue) / (2f * Step);
                    }

                    float[] ResultPlus = new float[CTFSpectraGrid.Elements()];
                    float[] ResultMinus = new float[CTFSpectraGrid.Elements()];

                    // ... take shortcut for defoci, ...
                    {
                        CubicGrid AlteredPhase = new CubicGrid(GridCTFPhase.Dimensions, input.Skip((int)GridCTF.Dimensions.Elements()).Take((int)GridCTFPhase.Dimensions.Elements()).Select(v => (float)v).ToArray());
                        float[] PhaseValues = AlteredPhase.GetInterpolatedNative(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, BorderZ));

                        {
                            CubicGrid AlteredPlus = new CubicGrid(GridCTF.Dimensions, input.Take((int)GridCTF.Dimensions.Elements()).Select(v => (float)v + Step).ToArray());
                            float[] DefocusValues = AlteredPlus.GetInterpolatedNative(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, BorderZ));

                            CTFStruct[] LocalParams = EvalGetCTF(input, CTF, DefocusValues, PhaseValues);

                            GPU.CTFCompareToSim(CTFSpectraPolarTrimmedHalf.GetDevice(Intent.Read),
                                                CTFCoordsPolarTrimmedHalf.GetDevice(Intent.Read),
                                                CTFSpectraScaleHalf.GetDevice(Intent.Read),
                                                (uint)CTFSpectraPolarTrimmedHalf.ElementsSliceReal,
                                                LocalParams,
                                                ResultPlus,
                                                (uint)LocalParams.Length);
                        }
                        {
                            CubicGrid AlteredMinus = new CubicGrid(GridCTF.Dimensions, input.Take((int)GridCTF.Dimensions.Elements()).Select(v => (float)v - Step).ToArray());
                            float[] DefocusValues = AlteredMinus.GetInterpolatedNative(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, BorderZ));

                            CTFStruct[] LocalParams = EvalGetCTF(input, CTF, DefocusValues, PhaseValues);

                            GPU.CTFCompareToSim(CTFSpectraPolarTrimmedHalf.GetDevice(Intent.Read),
                                                CTFCoordsPolarTrimmedHalf.GetDevice(Intent.Read),
                                                CTFSpectraScaleHalf.GetDevice(Intent.Read),
                                                (uint)CTFSpectraPolarTrimmedHalf.ElementsSliceReal,
                                                LocalParams,
                                                ResultMinus,
                                                (uint)LocalParams.Length);
                        }
                        float[] LocalGradients = new float[ResultPlus.Length];
                        for (int i = 0; i < LocalGradients.Length; i++)
                            LocalGradients[i] = ResultMinus[i] - ResultPlus[i];

                        // Now compute gradients per grid anchor point using the precomputed individual gradients and wiggle factors.
                        Parallel.For(0, GridCTF.Dimensions.Elements(), i => Result[i] = MathHelper.ReduceWeighted(LocalGradients, WiggleWeights[i]) / LocalGradients.Length / (2f * Step));
                    }

                    // ... and take shortcut for phases.
                    if (options.DoPhase)
                    {
                        CubicGrid AlteredPlus = new CubicGrid(GridCTF.Dimensions, input.Take((int)GridCTF.Dimensions.Elements()).Select(v => (float)v).ToArray());
                        float[] DefocusValues = AlteredPlus.GetInterpolatedNative(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, BorderZ));

                        {
                            CubicGrid AlteredPhasePlus = new CubicGrid(GridCTFPhase.Dimensions, input.Skip((int)GridCTF.Dimensions.Elements()).Take((int)GridCTFPhase.Dimensions.Elements()).Select(v => (float)v + Step).ToArray());
                            float[] PhaseValues = AlteredPhasePlus.GetInterpolatedNative(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, BorderZ));
                            CTFStruct[] LocalParams = EvalGetCTF(input, CTF, DefocusValues, PhaseValues);

                            GPU.CTFCompareToSim(CTFSpectraPolarTrimmedHalf.GetDevice(Intent.Read),
                                                CTFCoordsPolarTrimmedHalf.GetDevice(Intent.Read),
                                                CTFSpectraScaleHalf.GetDevice(Intent.Read),
                                                (uint)CTFSpectraPolarTrimmedHalf.ElementsSliceReal,
                                                LocalParams,
                                                ResultPlus,
                                                (uint)LocalParams.Length);
                        }
                        {
                            CubicGrid AlteredPhaseMinus = new CubicGrid(GridCTFPhase.Dimensions, input.Skip((int)GridCTF.Dimensions.Elements()).Take((int)GridCTFPhase.Dimensions.Elements()).Select(v => (float)v - Step).ToArray());
                            float[] PhaseValues = AlteredPhaseMinus.GetInterpolatedNative(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, BorderZ));
                            CTFStruct[] LocalParams = EvalGetCTF(input, CTF, DefocusValues, PhaseValues);

                            GPU.CTFCompareToSim(CTFSpectraPolarTrimmedHalf.GetDevice(Intent.Read),
                                                CTFCoordsPolarTrimmedHalf.GetDevice(Intent.Read),
                                                CTFSpectraScaleHalf.GetDevice(Intent.Read),
                                                (uint)CTFSpectraPolarTrimmedHalf.ElementsSliceReal,
                                                LocalParams,
                                                ResultMinus,
                                                (uint)LocalParams.Length);
                        }
                        float[] LocalGradients = new float[ResultPlus.Length];
                        for (int i = 0; i < LocalGradients.Length; i++)
                            LocalGradients[i] = ResultMinus[i] - ResultPlus[i];

                        // Now compute gradients per grid anchor point using the precomputed individual gradients and wiggle factors.
                        Parallel.For(0, GridCTFPhase.Dimensions.Elements(), i => Result[i + GridCTF.Dimensions.Elements()] = MathHelper.ReduceWeighted(LocalGradients, WiggleWeightsPhase[i]) / LocalGradients.Length / (2f * Step));
                    }

                    foreach (var i in Result)
                        if (double.IsNaN(i) || double.IsInfinity(i))
                            throw new Exception("Bad score.");

                    return Result;
                };

                #endregion

                #region Minimize first time with potential outpiers

                double[] StartParams = new double[GridCTF.Dimensions.Elements() + GridCTFPhase.Dimensions.Elements() + 2];
                for (int i = 0; i < GridCTF.Dimensions.Elements(); i++)
                    StartParams[i] = GridCTF.FlatValues[i];
                for (int i = 0; i < GridCTFPhase.Dimensions.Elements(); i++)
                    StartParams[i + GridCTF.Dimensions.Elements()] = GridCTFPhase.FlatValues[i];
                StartParams[StartParams.Length - 2] = (double)CTF.DefocusDelta;
                StartParams[StartParams.Length - 1] = (double)CTF.DefocusAngle / 20 * Helper.ToRad;

                // Compute correlation for individual spectra, and throw away those that are >.75 sigma worse than mean.

                #region Discard outliers

                if (CTFSpace || CTFTime)
                {
                    //CubicGrid Altered = new CubicGrid(GridCTF.Dimensions, StartParams.Take((int)GridCTF.Dimensions.Elements()).Select(v => (float)v).ToArray());
                    //float[] DefocusValues = Altered.GetInterpolatedNative(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, BorderZ));
                    //CubicGrid AlteredPhase = new CubicGrid(GridCTFPhase.Dimensions, StartParams.Skip((int)GridCTF.Dimensions.Elements()).Take((int)GridCTFPhase.Dimensions.Elements()).Select(v => (float)v).ToArray());
                    //float[] PhaseValues = AlteredPhase.GetInterpolatedNative(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, BorderZ));

                    //CTFStruct[] LocalParams = EvalGetCTF(StartParams, CTF, DefocusValues, PhaseValues);

                    //float[] Result = new float[LocalParams.Length];

                    //GPU.CTFCompareToSim(CTFSpectraPolarTrimmedHalf.GetDevice(Intent.Read),
                    //                    CTFCoordsPolarTrimmedHalf.GetDevice(Intent.Read),
                    //                    CTFSpectraScaleHalf.GetDevice(Intent.Read),
                    //                    (uint)CTFSpectraPolarTrimmedHalf.ElementsSliceReal,
                    //                    LocalParams,
                    //                    Result,
                    //                    (uint)LocalParams.Length);

                    //float MeanResult = MathHelper.Mean(Result);
                    //float StdResult = MathHelper.StdDev(Result);

                    CTFSpectraConsider = Helper.ArrayOfConstant(true, (int)CTFSpectraGrid.Elements());

                    //Parallel.For(0, CTFSpectraConsider.Length, i =>
                    //{
                    //    //if (Result[i] > MeanResult - StdResult * 1.5f)
                    //    CTFSpectraConsider[i] = true;
                    //    /*else
                    //    {
                    //        CTFSpectraConsider[i] = false;
                    //        for (int j = 0; j < WiggleWeights.Length; j++)
                    //            // Make sure the spectrum's gradient doesn't affect the overall gradient.
                    //            WiggleWeights[j][i] = 0;
                    //    }*/
                    //});
                    NCTFSpectraConsider = CTFSpectraConsider.Where(v => v).Count();
                }

                #endregion

                BroydenFletcherGoldfarbShanno Optimizer = new BroydenFletcherGoldfarbShanno(StartParams.Length, Eval, Gradient)
                {
                    MaxIterations = 15
                };
                Optimizer.Minimize(StartParams);

                #endregion

                #region Retrieve parameters

                CTF.Defocus = (decimal)MathHelper.Mean(Optimizer.Solution.Take((int)GridCTF.Dimensions.Elements()).Select(v => (float)v));
                CTF.DefocusDelta = (decimal)Optimizer.Solution[StartParams.Length - 2];
                CTF.DefocusAngle = (decimal)(Optimizer.Solution[StartParams.Length - 1] * 20 * Helper.ToDeg);
                CTF.PhaseShift = (decimal)MathHelper.Mean(Optimizer.Solution.Skip((int)GridCTF.Dimensions.Elements()).Take((int)GridCTFPhase.Dimensions.Elements()).Select(v => (float)v));

                if (CTF.DefocusDelta < 0)
                {
                    CTF.DefocusAngle += 90;
                    CTF.DefocusDelta *= -1;
                }
                CTF.DefocusAngle = ((int)CTF.DefocusAngle + 180 * 99) % 180;

                GridCTF = new CubicGrid(GridCTF.Dimensions, Optimizer.Solution.Take((int)GridCTF.Dimensions.Elements()).Select(v => (float)v).ToArray());
                GridCTFPhase = new CubicGrid(GridCTFPhase.Dimensions, Optimizer.Solution.Skip((int)GridCTF.Dimensions.Elements()).Take((int)GridCTFPhase.Dimensions.Elements()).Select(v => (float)v).ToArray());

                #endregion

                // Dispose GPU resources manually because GC can't be bothered to do it in time.
                CTFSpectraPolarTrimmedHalf.Dispose();
                CTFCoordsPolarTrimmedHalf.Dispose();
                CTFSpectraScaleHalf.Dispose();

                #region Get nicer envelope fit

                if (preciseFit >= 2)
                {
                    if (!CTFSpace && !CTFTime)
                    {
                        UpdateRotationalAverage(true);
                    }
                    else
                    {
                        Image CTFSpectraBackground = new Image(new int3(DimsRegion), true);
                        float[] CTFSpectraBackgroundData = CTFSpectraBackground.GetHost(Intent.Write)[0];

                        // Construct background in Cartesian coordinates.
                        Helper.ForEachElementFT(DimsRegion, (x, y, xx, yy, r, a) =>
                        {
                            CTFSpectraBackgroundData[y * CTFSpectraBackground.DimsEffective.X + x] = _SimulatedBackground.Interp(r / DimsRegion.X);
                        });

                        CTFSpectra.SubtractFromSlices(CTFSpectraBackground);

                        float[] DefocusValues = GridCTF.GetInterpolatedNative(CTFSpectraGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, BorderZ));
                        CTFStruct[] LocalParams = DefocusValues.Select(v =>
                        {
                            CTF Local = CTF.GetCopy();
                            Local.Defocus = (decimal)v + 0.0M;

                            return Local.ToStruct();
                        }).ToArray();

                        Image CTFAverage1D = new Image(IntPtr.Zero, new int3(DimsRegion.X / 2, 1, 1));

                        CTF CTFAug = CTF.GetCopy();
                        CTFAug.Defocus += 0.0M;
                        GPU.CTFMakeAverage(CTFSpectra.GetDevice(Intent.Read),
                                           CTFCoordsCart.GetDevice(Intent.Read),
                                           (uint)CTFSpectra.ElementsSliceReal,
                                           (uint)DimsRegion.X,
                                           LocalParams,
                                           CTFAug.ToStruct(),
                                           0,
                                           (uint)DimsRegion.X / 2,
                                           CTFSpectraConsider.Select(v => v ? 1 : 0).ToArray(),
                                           (uint)CTFSpectraGrid.Elements(),
                                           CTFAverage1D.GetDevice(Intent.Write));

                        CTFSpectra.AddToSlices(CTFSpectraBackground);

                        float[] RotationalAverageData = CTFAverage1D.GetHost(Intent.Read)[0];
                        float2[] ForPS1D = new float2[PS1D.Length];
                        for (int i = 0; i < ForPS1D.Length; i++)
                            ForPS1D[i] = new float2((float)i / DimsRegion.X, (float)Math.Round(RotationalAverageData[i], 4) + _SimulatedBackground.Interp((float)i / DimsRegion.X));
                        MathHelper.UnNaN(ForPS1D);
                        _PS1D = ForPS1D;

                        CTFSpectraBackground.Dispose();
                        CTFAverage1D.Dispose();
                        CTFSpectra.FreeDevice();
                    }

                    CTF.Defocus = Math.Max(CTF.Defocus, 0);
                    UpdateBackgroundFit();
                }

                #endregion
            }

            #endregion

            // Subtract background from 2D average and write it to disk. 
            // This image is used for quick visualization purposes only.

            #region PS2D update
            {
                int3 DimsAverage = new int3(DimsRegion.X, DimsRegion.X / 2, 1);
                float[] Average2DData = new float[DimsAverage.Elements()];
                float[] OriginalAverageData = CTFMean.GetHost(Intent.Read)[0];

                for (int y = 0; y < DimsAverage.Y; y++)
                {
                    int yy = y * y;
                    for (int x = 0; x < DimsAverage.Y; x++)
                    {
                        int xx = DimsRegion.X / 2 - x - 1;
                        xx *= xx;
                        float r = (float)Math.Sqrt(xx + yy) / DimsRegion.X;
                        Average2DData[y * DimsAverage.X + x] = OriginalAverageData[(y + DimsRegion.X / 2) * (DimsRegion.X / 2 + 1) + x] - SimulatedBackground.Interp(r);
                    }

                    for (int x = 0; x < DimsRegion.X / 2; x++)
                    {
                        int xx = x * x;
                        float r = (float)Math.Sqrt(xx + yy) / DimsRegion.X;
                        Average2DData[y * DimsAverage.X + x + DimsRegion.X / 2] = OriginalAverageData[(DimsRegion.X / 2 - y) * (DimsRegion.X / 2 + 1) + (DimsRegion.X / 2 - 1 - x)] - SimulatedBackground.Interp(r);
                    }
                }

                IOHelper.WriteMapFloat(PowerSpectrumPath,
                                       new HeaderMRC
                                       {
                                           Dimensions = DimsAverage,
                                           MinValue = MathHelper.Min(Average2DData),
                                           MaxValue = MathHelper.Max(Average2DData)
                                       },
                                       Average2DData);
            }
            #endregion

            for (int i = 0; i < PS1D.Length; i++)
                PS1D[i].Y -= SimulatedBackground.Interp(PS1D[i].X);
            SimulatedBackground = new Cubic1D(SimulatedBackground.Data.Select(v => new float2(v.X, 0f)).ToArray());

            CTFSpectra.Dispose();
            CTFMean.Dispose();
            CTFCoordsCart.Dispose();
            CTFCoordsPolarTrimmed.Dispose();

            Simulated1D = GetSimulated1D();
            //CTFQuality = GetCTFQuality();

            #region Estimate fittable resolution
            {
                float[] Quality = CTF.EstimateQuality(PS1D.Select(p => p.Y).ToArray(), SimulatedScale.Interp(PS1D.Select(p => p.X).ToArray()), (float)options.RangeMin, 6);
                int FirstFreq = 0;
                while ((float.IsNaN(Quality[FirstFreq]) || Quality[FirstFreq] < 0.8f) && FirstFreq < Quality.Length - 1)
                    FirstFreq++;

                int LastFreq = FirstFreq;
                while (!float.IsNaN(Quality[LastFreq]) && Quality[LastFreq] > 0.3f && LastFreq < Quality.Length - 1)
                    LastFreq++;

                CTFResolutionEstimate = options.BinnedPixelSizeMean / ((decimal)LastFreq / options.Window);
            }
            #endregion

            OptionsCTF = options;

            SaveMeta();

            IsProcessing = false;
        }

        public void ProcessShift(Image originalStack, ProcessingOptionsMovieMovement options)
        {
            IsProcessing = true;

            // Deal with dimensions and grids.

            int NFrames = originalStack.Dims.Z;
            int2 DimsImage = new int2(originalStack.Dims);
            int2 DimsRegion = new int2(512, 512);

            float OverlapFraction = 0.5f;
            int2 DimsPositionGrid;
            int3[] PositionGrid = Helper.GetEqualGridSpacing(DimsImage, DimsRegion, OverlapFraction, out DimsPositionGrid);
            //PositionGrid = new[] { new int3(0, 0, 0) };
            //DimsPositionGrid = new int2(1, 1);
            int NPositions = PositionGrid.Length;

            int ShiftGridX = options.GridDims.X;
            int ShiftGridY = options.GridDims.Y;
            int ShiftGridZ = Math.Min(NFrames, options.GridDims.Z);
            GridMovementX = new CubicGrid(new int3(ShiftGridX, ShiftGridY, ShiftGridZ));
            GridMovementY = new CubicGrid(new int3(ShiftGridX, ShiftGridY, ShiftGridZ));

            int LocalGridX = Math.Min(DimsPositionGrid.X, options.GridDims.X);
            int LocalGridY = Math.Min(DimsPositionGrid.Y, options.GridDims.Y);
            int LocalGridZ = Math.Min(2, NFrames);
            GridLocalX = new CubicGrid(new int3(LocalGridX, LocalGridY, LocalGridZ));
            GridLocalY = new CubicGrid(new int3(LocalGridX, LocalGridY, LocalGridZ));

            int3 ShiftGrid = new int3(DimsPositionGrid.X, DimsPositionGrid.Y, NFrames);

            int MinFreqInclusive = (int)(options.RangeMin * DimsRegion.X / 2);
            int MaxFreqExclusive = (int)(options.RangeMax * DimsRegion.X / 2);
            int NFreq = MaxFreqExclusive - MinFreqInclusive;

            int CentralFrame = NFrames / 2;

            int MaskExpansions = Math.Max(1, (int)Math.Ceiling(Math.Log(ShiftGridZ - 0.01, 3)));    // Each expansion doubles the temporal resolution
            int[] MaskSizes = new int[MaskExpansions];

            // Allocate memory and create all prerequisites:
            int MaskLength;
            Image ShiftFactors;
            Image Patches;
            Image PatchesAverage;
            Image Shifts;
            {
                List<long> Positions = new List<long>();
                List<float2> Factors = new List<float2>();
                List<float2> Freq = new List<float2>();
                int Min2 = MinFreqInclusive * MinFreqInclusive;
                int Max2 = MaxFreqExclusive * MaxFreqExclusive;
                float PixelSize = (float)options.BinnedPixelSizeMean;

                for (int y = 0; y < DimsRegion.Y; y++)
                {
                    int yy = y - DimsRegion.X / 2;
                    for (int x = 0; x < DimsRegion.X / 2 + 1; x++)
                    {
                        int xx = x - DimsRegion.X / 2;
                        int r2 = xx * xx + yy * yy;
                        if (r2 >= Min2 && r2 < Max2)
                        {
                            Positions.Add(y * (DimsRegion.X / 2 + 1) + x);
                            Factors.Add(new float2((float)xx / DimsRegion.X * 2f * (float)Math.PI,
                                                   (float)yy / DimsRegion.X * 2f * (float)Math.PI));

                            float Angle = (float)Math.Atan2(yy, xx);
                            float r = (float)Math.Sqrt(r2);
                            Freq.Add(new float2(r, Angle));
                        }
                    }
                }

                // Sort everyone by ascending distance from center.
                List<KeyValuePair<float, int>> FreqIndices = Freq.Select((v, i) => new KeyValuePair<float, int>(v.X, i)).ToList();
                FreqIndices.Sort((a, b) => a.Key.CompareTo(b.Key));
                int[] SortedIndices = FreqIndices.Select(v => v.Value).ToArray();

                Helper.Reorder(Positions, SortedIndices);
                Helper.Reorder(Factors, SortedIndices);
                Helper.Reorder(Freq, SortedIndices);

                float Bfac = (float)options.Bfactor * 0.25f / PixelSize / DimsRegion.X;
                float[] BfacWeightsData = Freq.Select(v => (float)Math.Exp(v.X * Bfac)).ToArray();
                Image BfacWeights = new Image(BfacWeightsData, false, false, false);

                long[] RelevantMask = Positions.ToArray();
                ShiftFactors = new Image(Helper.ToInterleaved(Factors.ToArray()));
                MaskLength = RelevantMask.Length;

                // Get mask sizes for different expansion steps.
                for (int i = 0; i < MaskExpansions; i++)
                {
                    float CurrentMaxFreq = MinFreqInclusive + (MaxFreqExclusive - MinFreqInclusive) / (float)MaskExpansions * (i + 1);
                    MaskSizes[i] = Freq.Count(v => v.X * v.X < CurrentMaxFreq * CurrentMaxFreq);
                }

                Patches = new Image(IntPtr.Zero, new int3(MaskLength, DimsPositionGrid.X * DimsPositionGrid.Y, NFrames), false, true, false);

                GPU.CreateShift(originalStack.GetDevice(Intent.Read),
                                DimsImage,
                                originalStack.Dims.Z,
                                PositionGrid,
                                PositionGrid.Length,
                                DimsRegion,
                                RelevantMask,
                                (uint)MaskLength,
                                Patches.GetDevice(Intent.Write));

                Patches.MultiplyLines(BfacWeights);
                BfacWeights.Dispose();

                originalStack.FreeDevice();
                PatchesAverage = new Image(IntPtr.Zero, new int3(MaskLength, NPositions, 1), false, true);
                Shifts = new Image(new float[NPositions * NFrames * 2]);
            }

            #region Fit movement

            {
                int MinXSteps = 1, MinYSteps = 1;
                int MinZSteps = Math.Min(NFrames, 3);
                int3 ExpansionGridSize = new int3(MinXSteps, MinYSteps, MinZSteps);
                float[][] WiggleWeights = new CubicGrid(ExpansionGridSize).GetWiggleWeights(ShiftGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, 0f));
                double[] StartParams = new double[ExpansionGridSize.Elements() * 2];

                for (int m = 0; m < MaskExpansions; m++)
                {
                    double[] LastAverage = null;

                    #region Helper methods

                    Action<double[]> SetPositions = input =>
                    {
                        // Construct CubicGrids and get interpolated shift values.
                        CubicGrid AlteredGridX = new CubicGrid(ExpansionGridSize, input.Where((v, i) => i % 2 == 0).Select(v => (float)v).ToArray());
                        float[] AlteredX = AlteredGridX.GetInterpolatedNative(new int3(DimsPositionGrid.X, DimsPositionGrid.Y, NFrames),
                                                                              new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, 0f));
                        CubicGrid AlteredGridY = new CubicGrid(ExpansionGridSize, input.Where((v, i) => i % 2 == 1).Select(v => (float)v).ToArray());
                        float[] AlteredY = AlteredGridY.GetInterpolatedNative(new int3(DimsPositionGrid.X, DimsPositionGrid.Y, NFrames),
                                                                              new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, 0f));
                        
                        // Finally, set the shift values in the device array.
                        float[] ShiftData = Shifts.GetHost(Intent.Write)[0];
                        Parallel.For(0, AlteredX.Length, i =>
                        {
                            ShiftData[i * 2] = AlteredX[i];// - CenterFrameOffsets[i % NPositions].X;
                            ShiftData[i * 2 + 1] = AlteredY[i];// - CenterFrameOffsets[i % NPositions].Y;
                        });
                    };

                    Action<double[]> DoAverage = input =>
                    {
                        if (LastAverage == null || input.Where((t, i) => t != LastAverage[i]).Any())
                        {
                            SetPositions(input);
                            GPU.ShiftGetAverage(Patches.GetDevice(Intent.Read),
                                                PatchesAverage.GetDevice(Intent.Write),
                                                ShiftFactors.GetDevice(Intent.Read),
                                                (uint)MaskLength,
                                                (uint)MaskSizes[m],
                                                Shifts.GetDevice(Intent.Read),
                                                (uint)NPositions,
                                                (uint)NFrames);

                            if (LastAverage == null)
                                LastAverage = new double[input.Length];
                            Array.Copy(input, LastAverage, input.Length);
                        }
                    };

                    #endregion

                    #region Eval and gradient methods

                    Func<double[], double> Eval = input =>
                    {
                        DoAverage(input);

                        float[] Diff = new float[NPositions * NFrames];
                        GPU.ShiftGetDiff(Patches.GetDevice(Intent.Read),
                                         PatchesAverage.GetDevice(Intent.Read),
                                         ShiftFactors.GetDevice(Intent.Read),
                                         (uint)MaskLength,
                                         (uint)MaskSizes[m],
                                         Shifts.GetDevice(Intent.Read),
                                         Diff,
                                         (uint)NPositions,
                                         (uint)NFrames);

                        for (int i = 0; i < Diff.Length; i++)
                            Diff[i] = Diff[i];

                        return Diff.Sum();
                    };

                    Func<double[], double[]> Grad = input =>
                    {
                        DoAverage(input);

                        float[] GradX = new float[NPositions * NFrames], GradY = new float[NPositions * NFrames];

                        float[] Diff = new float[NPositions * NFrames * 2];
                        GPU.ShiftGetGrad(Patches.GetDevice(Intent.Read),
                                         PatchesAverage.GetDevice(Intent.Read),
                                         ShiftFactors.GetDevice(Intent.Read),
                                         (uint)MaskLength,
                                         (uint)MaskSizes[m],
                                         Shifts.GetDevice(Intent.Read),
                                         Diff,
                                         (uint)NPositions,
                                         (uint)NFrames);
                        
                        for (int i = 0; i < GradX.Length; i++)
                        {
                            GradX[i] = Diff[i * 2];
                            GradY[i] = Diff[i * 2 + 1];
                        }

                        double[] Result = new double[input.Length];
                        Parallel.For(0, input.Length / 2, i =>
                        {
                            Result[i * 2] = MathHelper.ReduceWeighted(GradX, WiggleWeights[i]);
                            Result[i * 2 + 1] = MathHelper.ReduceWeighted(GradY, WiggleWeights[i]);
                        });
                        return Result;
                    };

                    #endregion

                    BroydenFletcherGoldfarbShanno Optimizer = new BroydenFletcherGoldfarbShanno(StartParams.Length, Eval, Grad);
                    Optimizer.MaxIterations = 10;
                    Optimizer.Minimize(StartParams);

                    float MeanX = MathHelper.Mean(Optimizer.Solution.Where((v, i) => i % 2 == 0).Select(v => (float)v));
                    float MeanY = MathHelper.Mean(Optimizer.Solution.Where((v, i) => i % 2 == 1).Select(v => (float)v));
                    for (int i = 0; i < ExpansionGridSize.Elements(); i++)
                    {
                        Optimizer.Solution[i * 2] -= MeanX;
                        Optimizer.Solution[i * 2 + 1] -= MeanY;
                    }

                    // Store coarse values in grids.
                    GridMovementX = new CubicGrid(ExpansionGridSize, Optimizer.Solution.Where((v, i) => i % 2 == 0).Select(v => (float)v).ToArray());
                    GridMovementY = new CubicGrid(ExpansionGridSize, Optimizer.Solution.Where((v, i) => i % 2 == 1).Select(v => (float)v).ToArray());

                    if (m < MaskExpansions - 1)
                    {
                        // Refine sampling.
                        ExpansionGridSize = new int3((int)Math.Round((float)(ShiftGridX - MinXSteps) / (MaskExpansions - 1) * (m + 1) + MinXSteps),
                                                     (int)Math.Round((float)(ShiftGridY - MinYSteps) / (MaskExpansions - 1) * (m + 1) + MinYSteps),
                                                     (int)Math.Round((float)Math.Min(ShiftGridZ, Math.Pow(3, m + 2))));
                        WiggleWeights = new CubicGrid(ExpansionGridSize).GetWiggleWeights(ShiftGrid, new float3(DimsRegion.X / 2f / DimsImage.X, DimsRegion.Y / 2f / DimsImage.Y, 0f));

                        // Resize the grids to account for finer sampling.
                        GridMovementX = GridMovementX.Resize(ExpansionGridSize);
                        GridMovementY = GridMovementY.Resize(ExpansionGridSize);

                        // Construct start parameters for next optimization iteration.
                        StartParams = new double[ExpansionGridSize.Elements() * 2];
                        for (int i = 0; i < ExpansionGridSize.Elements(); i++)
                        {
                            StartParams[i * 2] = GridMovementX.FlatValues[i];
                            StartParams[i * 2 + 1] = GridMovementY.FlatValues[i];
                        }
                    }
                }
            }

            #endregion

            // Center the global shifts
            {
                float2 AverageShift =  new float2(MathHelper.Mean(GridMovementX.FlatValues),
                                                  MathHelper.Mean(GridMovementY.FlatValues));

                GridMovementX = new CubicGrid(GridMovementX.Dimensions, GridMovementX.FlatValues.Select(v => v - AverageShift.X).ToArray());
                GridMovementY = new CubicGrid(GridMovementY.Dimensions, GridMovementY.FlatValues.Select(v => v - AverageShift.Y).ToArray());
            }

            // Scale everything from (binned) pixels to Angstrom
            GridMovementX = new CubicGrid(GridMovementX.Dimensions, GridMovementX.FlatValues.Select(v => v * (float)options.BinnedPixelSizeMean).ToArray());
            GridMovementY = new CubicGrid(GridMovementY.Dimensions, GridMovementY.FlatValues.Select(v => v * (float)options.BinnedPixelSizeMean).ToArray());

            ShiftFactors.Dispose();
            Patches.Dispose();
            PatchesAverage.Dispose();
            Shifts.Dispose();

            OptionsMovement = options;

            // Calculate mean per-frame shift
            {
                float2[] Track = GetMotionTrack(new float2(0.5f, 0.5f), 1);
                float[] Diff = MathHelper.Diff(Track).Select(v => v.Length()).ToArray();
                MeanFrameMovement = (decimal)MathHelper.Mean(Diff);
            }

            SaveMeta();

            IsProcessing = false;
        }

        private float2 GetShiftFromPyramid(float3 coords)
        {
            float2 Result = new float2(0, 0);

            Result.X = GridMovementX.GetInterpolated(coords);
            Result.Y = GridMovementY.GetInterpolated(coords);

            for (int i = 0; i < PyramidShiftX.Count; i++)
            //for (int i = 0; i < 0; i++)
            {
                Result.X += PyramidShiftX[i].GetInterpolated(coords);
                Result.Y += PyramidShiftY[i].GetInterpolated(coords);
            }

            return Result;
        }

        public void CreateCorrectedMovie(Image originalStack, ProcessingOptionsMovieExport options)
        {
            IsProcessing = true;

            if (!Directory.Exists(AverageDir))
                Directory.CreateDirectory(AverageDir);

            if (options.DoStack && !Directory.Exists(ShiftedStackDir))
                Directory.CreateDirectory(ShiftedStackDir);

            if (options.DoDeconv && !Directory.Exists(DeconvolvedStackDir))
                Directory.CreateDirectory(DeconvolvedStackDir);

            int3 Dims = originalStack.Dims;

            Image ShiftedStack = null;
            if (options.DoStack)
                ShiftedStack = new Image(Dims);

            float PixelSize = (float)options.BinnedPixelSizeMean;
            float PixelDelta = (float)options.BinnedPixelSizeDelta;
            float PixelAngle = (float)options.PixelSizeAngle * Helper.ToRad;
            Image CTFCoords;
            {
                float2[] CTFCoordsData = new float2[Dims.ElementsSlice()];
                Helper.ForEachElementFT(new int2(Dims), (x, y, xx, yy) =>
                {
                    float xs = xx / (float)Dims.X;
                    float ys = yy / (float)Dims.Y;
                    float r = (float)Math.Sqrt(xs * xs + ys * ys);
                    float angle = (float)Math.Atan2(yy, xx);
                    float CurrentPixelSize = PixelSize + PixelDelta * (float)Math.Cos(2f * (angle - PixelAngle));

                    CTFCoordsData[y * (Dims.X / 2 + 1) + x] = new float2(r / CurrentPixelSize, angle);
                });

                CTFCoords = new Image(CTFCoordsData, Dims.Slice(), true);
            }
            Image CTFFreq = CTFCoords.AsReal();
            CTFCoords.Dispose();

            CubicGrid CollapsedMovementX = GridMovementX.CollapseXY();
            CubicGrid CollapsedMovementY = GridMovementY.CollapseXY();
            CubicGrid CollapsedCTF = GridCTF.CollapseXY();
            Image AverageFT = new Image(Dims.Slice(), true, true);
            Image Weights = new Image(Dims.Slice(), true, false);
            Weights.Fill(1e-6f);

            float StepZ = 1f / Math.Max(Dims.Z - 1, 1);

            for (int nframe = Math.Max(0, options.SkipFirstN); nframe < Math.Min(Dims.Z, Dims.Z - options.SkipLastN); nframe++)
            {
                Image PS = new Image(Dims.Slice(), true);
                PS.Fill(1f);

                // Apply motion blur filter.
                /*{
                    float StartZ = (nframe - 0.5f) * StepZ;
                    float StopZ = (nframe + 0.5f) * StepZ;

                    float2[] Shifts = new float2[21];
                    for (int z = 0; z < Shifts.Length; z++)
                    {
                        float zp = StartZ + (StopZ - StartZ) / (Shifts.Length - 1) * z;
                        Shifts[z] = new float2(CollapsedMovementX.GetInterpolated(new float3(0.5f, 0.5f, zp)),
                                               CollapsedMovementY.GetInterpolated(new float3(0.5f, 0.5f, zp)));
                    }
                    // Center the shifts around 0
                    float2 ShiftMean = MathHelper.Mean(Shifts);
                    Shifts = Shifts.Select(v => v - ShiftMean).ToArray();

                    Image MotionFilter = new Image(IntPtr.Zero, Dims.Slice(), true);
                    GPU.CreateMotionBlur(MotionFilter.GetDevice(Intent.Write), 
                                         MotionFilter.Dims, 
                                         Helper.ToInterleaved(Shifts.Select(v => new float3(v.X, v.Y, 0)).ToArray()), 
                                         (uint)Shifts.Length, 
                                         1);
                    PS.Multiply(MotionFilter);
                    //MotionFilter.WriteMRC("motion.mrc");
                    MotionFilter.Dispose();
                }*/

                // Apply dose weighting.
                {
                    float3 NikoConst = new float3(0.245f, -1.665f, 2.81f);

                    // Niko's formula expects e-/A2/frame.
                    float FrameDose = (float)options.DosePerAngstromFrame * (nframe + 0.5f);

                    Image DoseImage = new Image(IntPtr.Zero, Dims.Slice(), true);
                    GPU.DoseWeighting(CTFFreq.GetDevice(Intent.Read),
                                      DoseImage.GetDevice(Intent.Write),
                                      (uint)DoseImage.ElementsSliceComplex,
                                      new[] { FrameDose },
                                      NikoConst,
                                      1);
                    PS.Multiply(DoseImage);
                    //DoseImage.WriteMRC("dose.mrc");
                    DoseImage.Dispose();
                }

                Image Frame = new Image(originalStack.GetHost(Intent.Read)[nframe], Dims.Slice());
                Frame.ShiftSlicesMassive(new[]
                {
                    new float3(CollapsedMovementX.GetInterpolated(new float3(0.5f, 0.5f, nframe * StepZ)) / (float)options.BinnedPixelSizeMean,
                               CollapsedMovementY.GetInterpolated(new float3(0.5f, 0.5f, nframe * StepZ)) / (float)options.BinnedPixelSizeMean,
                               0f)
                });
                if (options.DoStack)
                    ShiftedStack.GetHost(Intent.Write)[nframe] = Frame.GetHost(Intent.Read)[0];

                Image FrameFT = Frame.AsFFT();
                Frame.Dispose();

                FrameFT.Multiply(PS);
                AverageFT.Add(FrameFT);
                Weights.Add(PS);

                //PS.WriteMRC("ps.mrc");

                PS.Dispose();
                FrameFT.Dispose();

            }
            CTFFreq.Dispose();

            AverageFT.Divide(Weights);
            //AverageFT.WriteMRC("averageft.mrc");
            //Weights.WriteMRC("weights.mrc");
            Weights.Dispose();

            Image Average = AverageFT.AsIFFT();
            AverageFT.Dispose();

            Average.WriteMRC(AveragePath, (float)options.BinnedPixelSizeMean, true);
            Average.Dispose();
            OnAverageChanged();
            
            using (TextWriter Writer = File.CreateText(AverageDir + RootName + "_ctffind3.log"))
            {
                decimal Mag = 50000M / options.BinnedPixelSizeMean;

                Writer.WriteLine("CS[mm], HT[kV], AmpCnst, XMAG, DStep[um]");
                Writer.WriteLine($"{CTF.Cs} {CTF.Voltage} {CTF.Amplitude} {Mag} {50000}");
                
                Writer.WriteLine($"{(CTF.Defocus + CTF.DefocusDelta / 2M) * 1e4M} {(CTF.Defocus - CTF.DefocusDelta / 2M) * 1e4M} {CTF.DefocusAngle} {1.0} {CTF.PhaseShift * 180M} Final Values");
            }

            if (options.DoStack)
                ShiftedStack.WriteMRC(ShiftedStackPath, (float)options.BinnedPixelSizeMean);

            OptionsMovieExport = options;
            SaveMeta();

            IsProcessing = false;
        }

        public float2[] GetMotionTrack(float2 position, int samples)
        {
            if (OptionsMovement == null || OptionsMovement.Dimensions.Z <= 1)
                return null;

            int NFrames = OptionsMovement.Dimensions.Z;

            float BorderX = 0.01f, BorderY = 0.01f;
            position.X = Math.Max(BorderX, Math.Min(1f - BorderX, position.X));
            position.Y = Math.Max(BorderY, Math.Min(1f - BorderY, position.Y));
            float2[] Result = new float2[NFrames * samples];

            float StepZ = 1f / Math.Max(NFrames * samples - 1, 1);
            for (int z = 0; z < NFrames * samples; z++)
                Result[z] = GetShiftFromPyramid(new float3(position.X, position.Y, z * StepZ));

            return Result;
        }

        public void UpdateStarDefocus(Star table, int2 dimensions)
        {
            string[] ColumnNames = table.GetColumn("rlnMicrographName");
            string[] ColumnCoordsX = table.GetColumn("rlnCoordinateX");
            string[] ColumnCoordsY = table.GetColumn("rlnCoordinateY");

            List<int> NameIndices = new List<int>();
            string InvariantRoot = RootName;
            for (int i = 0; i < ColumnNames.Length; i++)
                if (ColumnNames[i].Contains(InvariantRoot))
                    NameIndices.Add(i);
                
            foreach (var nameIndex in NameIndices)
            {
                float CoordX = float.Parse(ColumnCoordsX[nameIndex], CultureInfo.InvariantCulture);
                float CoordY = float.Parse(ColumnCoordsY[nameIndex], CultureInfo.InvariantCulture);

                float LocalDefocus = GridCTF.GetInterpolated(new float3(CoordX / (dimensions.X - 1), CoordY / (dimensions.Y - 1), 0.5f));
                table.SetRowValue(nameIndex, "rlnDefocusU", ((LocalDefocus + (float)CTF.DefocusDelta / 2f) * 1e4f).ToString(CultureInfo.InvariantCulture));
                table.SetRowValue(nameIndex, "rlnDefocusV", ((LocalDefocus - (float)CTF.DefocusDelta / 2f) * 1e4f).ToString(CultureInfo.InvariantCulture));
                table.SetRowValue(nameIndex, "rlnDefocusAngle", ((float)CTF.DefocusAngle).ToString(CultureInfo.InvariantCulture));
                
                table.SetRowValue(nameIndex, "rlnSphericalAberration", ((float)CTF.Cs).ToString(CultureInfo.InvariantCulture));
                float LocalPhaseShift = GridCTFPhase.GetInterpolated(new float3(0.5f, 0.5f, 0.5f));
                table.SetRowValue(nameIndex, "rlnPhaseShift", (LocalPhaseShift * 180f).ToString(CultureInfo.InvariantCulture));
            }
        }

        public void ExportParticles(Star tableIn, Star tableOut, Image originalStack, ProcessingOptionsParticlesExport options)
        {
            //List<int> RowIndices = new List<int>();
            //string[] ColumnMicrographName = tableIn.GetColumn("rlnMicrographName");
            //for (int i = 0; i < ColumnMicrographName.Length; i++)
            //    if (ColumnMicrographName[i].Contains(RootName))
            //        RowIndices.Add(i);

            //if (RowIndices.Count == 0)
            //    return;

            //if (!Directory.Exists(ParticlesDir))
            //    Directory.CreateDirectory(ParticlesDir);
            //if (!Directory.Exists(ParticleCTFDir))
            //    Directory.CreateDirectory(ParticleCTFDir);

            //int3 Dims = originalHeader.Dimensions;
            //int3 DimsRegion = new int3(size, size, 1);
            //int3 DimsPadded = new int3(size * 2, size * 2, 1);
            //int NParticles = RowIndices.Count;

            //float PixelSize = (float)CTF.PixelSize;
            ///*Image CTFCoords;
            //Image CTFFreq;
            //{
            //    float2[] CTFCoordsData = new float2[(DimsRegion.X / 2 + 1) * DimsRegion.Y];
            //    float[] CTFFreqData = new float[(DimsRegion.X / 2 + 1) * DimsRegion.Y];
            //    for (int y = 0; y < DimsRegion.Y; y++)
            //        for (int x = 0; x < DimsRegion.X / 2 + 1; x++)
            //        {
            //            int xx = x;
            //            int yy = y < DimsRegion.Y / 2 + 1 ? y : y - DimsRegion.Y;

            //            float xs = xx / (float)DimsRegion.X;
            //            float ys = yy / (float)DimsRegion.Y;
            //            float r = (float)Math.Sqrt(xs * xs + ys * ys);
            //            float angle = (float)(Math.Atan2(yy, xx));
            //            float CurrentPixelSize = PixelSize + PixelDelta * (float)Math.Cos(2f * (angle - PixelAngle));

            //            CTFCoordsData[y * (DimsRegion.X / 2 + 1) + x] = new float2(r / DimsRegion.X, angle);
            //            CTFFreqData[y * (DimsRegion.X / 2 + 1) + x] = r / CurrentPixelSize;
            //        }

            //    CTFCoords = new Image(CTFCoordsData, DimsRegion.Slice(), true);
            //    CTFFreq = new Image(CTFFreqData, DimsRegion.Slice(), true);
            //}*/

            //string[] ColumnPosX = tableIn.GetColumn("rlnCoordinateX");
            //string[] ColumnPosY = tableIn.GetColumn("rlnCoordinateY");
            //string[] ColumnOriginX = tableIn.GetColumn("rlnOriginX");
            //string[] ColumnOriginY = tableIn.GetColumn("rlnOriginY");
            //int3[] Origins = new int3[NParticles];
            //float3[] ResidualShifts = new float3[NParticles];

            //for (int i = 0; i < NParticles; i++)
            //{
            //    float2 Pos = new float2(float.Parse(ColumnPosX[RowIndices[i]], CultureInfo.InvariantCulture),
            //                            float.Parse(ColumnPosY[RowIndices[i]], CultureInfo.InvariantCulture)) * 1.00f;
            //    float2 Shift = new float2(float.Parse(ColumnOriginX[RowIndices[i]], CultureInfo.InvariantCulture),
            //                              float.Parse(ColumnOriginY[RowIndices[i]], CultureInfo.InvariantCulture)) * 1.00f;

            //    Origins[i] = new int3((int)(Pos.X - Shift.X),
            //                          (int)(Pos.Y - Shift.Y),
            //                          0);
            //    ResidualShifts[i] = new float3(-MathHelper.ResidualFraction(Pos.X - Shift.X),
            //                                   -MathHelper.ResidualFraction(Pos.Y - Shift.Y),
            //                                   0f);

            //    tableIn.SetRowValue(RowIndices[i], "rlnCoordinateX", Origins[i].X.ToString());
            //    tableIn.SetRowValue(RowIndices[i], "rlnCoordinateY", Origins[i].Y.ToString());
            //    tableIn.SetRowValue(RowIndices[i], "rlnOriginX", "0.0");
            //    tableIn.SetRowValue(RowIndices[i], "rlnOriginY", "0.0");
            //}

            //Image AverageFT = new Image(new int3(DimsRegion.X, DimsRegion.Y, NParticles), true, true);
            //Image AveragePS = new Image(new int3(DimsRegion.X, DimsRegion.Y, NParticles), true);
            //Image Weights = new Image(new int3(DimsRegion.X, DimsRegion.Y, NParticles), true);
            //Weights.Fill(1e-6f);
            //Image FrameParticles = new Image(IntPtr.Zero, new int3(DimsPadded.X, DimsPadded.Y, NParticles));

            //float StepZ = 1f / Math.Max(Dims.Z - 1, 1);
            //for (int z = 0; z < Dims.Z; z++)
            //{
            //    float CoordZ = z * StepZ;

            //    if (originalStack != null)
            //        GPU.Extract(originalStack.GetDeviceSlice(z, Intent.Read),
            //                    FrameParticles.GetDevice(Intent.Write),
            //                    Dims.Slice(),
            //                    DimsPadded,
            //                    Helper.ToInterleaved(Origins.Select(v => new int3(v.X - DimsPadded.X / 2, v.Y - DimsPadded.Y / 2, 0)).ToArray()),
            //                    (uint)NParticles);

            //    // Shift particles
            //    {
            //        float3[] Shifts = new float3[NParticles];

            //        for (int i = 0; i < NParticles; i++)
            //        {
            //            float3 Coords = new float3((float)Origins[i].X / Dims.X, (float)Origins[i].Y / Dims.Y, CoordZ);
            //            Shifts[i] = ResidualShifts[i] + new float3(GetShiftFromPyramid(Coords)) * 1.00f;
            //        }
            //        FrameParticles.ShiftSlices(Shifts);
            //    }

            //    Image FrameParticlesCropped = FrameParticles.AsPadded(new int2(DimsRegion));
            //    Image FrameParticlesFT = FrameParticlesCropped.AsFFT();
            //    FrameParticlesCropped.Dispose();

            //    //Image PS = new Image(new int3(DimsRegion.X, DimsRegion.Y, NParticles), true);
            //    //PS.Fill(1f);

            //    // Apply motion blur filter.

            //    #region Motion blur weighting

            //    /*{
            //        const int Samples = 11;
            //        float StartZ = (z - 0.5f) * StepZ;
            //        float StopZ = (z + 0.5f) * StepZ;

            //        float2[] Shifts = new float2[Samples * NParticles];
            //        for (int p = 0; p < NParticles; p++)
            //        {
            //            float NormX = (float)Origins[p].X / Dims.X;
            //            float NormY = (float)Origins[p].Y / Dims.Y;

            //            for (int zz = 0; zz < Samples; zz++)
            //            {
            //                float zp = StartZ + (StopZ - StartZ) / (Samples - 1) * zz;
            //                float3 Coords = new float3(NormX, NormY, zp);
            //                Shifts[p * Samples + zz] = GetShiftFromPyramid(Coords);
            //            }
            //        }

            //        Image MotionFilter = new Image(IntPtr.Zero, new int3(DimsRegion.X, DimsRegion.Y, NParticles), true);
            //        GPU.CreateMotionBlur(MotionFilter.GetDevice(Intent.Write),
            //                             DimsRegion,
            //                             Helper.ToInterleaved(Shifts.Select(v => new float3(v.X, v.Y, 0)).ToArray()),
            //                             Samples,
            //                             (uint)NParticles);
            //        PS.Multiply(MotionFilter);
            //        //MotionFilter.WriteMRC("motion.mrc");
            //        MotionFilter.Dispose();
            //    }*/

            //    #endregion

            //    // Apply CTF.

            //    #region CTF weighting

            //    /*if (CTF != null)
            //    {
            //        CTFStruct[] Structs = new CTFStruct[NParticles];
            //        for (int p = 0; p < NParticles; p++)
            //        {
            //            CTF Altered = CTF.GetCopy();
            //            Altered.Defocus = (decimal)GridCTF.GetInterpolated(new float3(Origins[p].X / Dims.X,
            //                                                                          Origins[p].Y / Dims.Y,
            //                                                                          z * StepZ));

            //            Structs[p] = Altered.ToStruct();
            //        }

            //        Image CTFImage = new Image(IntPtr.Zero, new int3(DimsRegion.X, DimsRegion.Y, NParticles), true);
            //        GPU.CreateCTF(CTFImage.GetDevice(Intent.Write),
            //                      CTFCoords.GetDevice(Intent.Read),
            //                      (uint)CTFCoords.ElementsSliceComplex,
            //                      Structs,
            //                      false,
            //                      (uint)NParticles);

            //        //CTFImage.Abs();
            //        PS.Multiply(CTFImage);
            //        //CTFImage.WriteMRC("ctf.mrc");
            //        CTFImage.Dispose();
            //    }*/

            //    #endregion

            //    // Apply dose.

            //    #region Dose weighting
            //    /*{
            //        float3 NikoConst = new float3(0.245f, -1.665f, 2.81f);

            //        // Niko's formula expects e-/A2/frame, we've got e-/px/frame -- convert!
            //        float FrameDose = (float)MainWindow.Options.CorrectDosePerFrame * (z + 0.5f) / (PixelSize * PixelSize);

            //        Image DoseImage = new Image(IntPtr.Zero, DimsRegion, true);
            //        GPU.DoseWeighting(CTFFreq.GetDevice(Intent.Read),
            //                          DoseImage.GetDevice(Intent.Write),
            //                          (uint)DoseImage.ElementsSliceComplex,
            //                          new[] { FrameDose },
            //                          NikoConst,
            //                          1);
            //        PS.MultiplySlices(DoseImage);
            //        //DoseImage.WriteMRC("dose.mrc");
            //        DoseImage.Dispose();
            //    }*/
            //    #endregion

            //    //Image PSAbs = new Image(PS.GetDevice(Intent.Read), new int3(DimsRegion.X, DimsRegion.Y, NParticles), true);
            //    //PSAbs.Abs();

            //    //FrameParticlesFT.Multiply(PS);
            //    AverageFT.Add(FrameParticlesFT);

            //    //Weights.Add(PSAbs);

            //    //PS.Multiply(PS);
            //    //AveragePS.Add(PS);

            //    //PS.Dispose();
            //    FrameParticlesFT.Dispose();
            //    //PSAbs.Dispose();
            //}
            //FrameParticles.Dispose();
            ////CTFCoords.Dispose();

            ////AverageFT.Divide(Weights);
            ////AveragePS.Divide(Weights);
            ////AverageFT.Multiply(AveragePS);
            //Weights.Dispose();

            //Image AverageParticlesUncorrected = AverageFT.AsIFFT();
            //AverageFT.Dispose();

            //Image AverageParticles = AverageParticlesUncorrected.AsAnisotropyCorrected(new int2(DimsRegion),
            //                                                                           (float)(CTF.PixelSize + CTF.PixelSizeDelta / 2M),
            //                                                                           (float)(CTF.PixelSize - CTF.PixelSizeDelta / 2M),
            //                                                                           (float)CTF.PixelSizeAngle * Helper.ToRad,
            //                                                                           8);
            //AverageParticlesUncorrected.Dispose();

            //GPU.NormParticles(AverageParticles.GetDevice(Intent.Read),
            //                  AverageParticles.GetDevice(Intent.Write),
            //                  DimsRegion,
            //                  (uint)(particleradius / (PixelSize / 1.00f)),
            //                  true,
            //                  (uint)NParticles);

            //HeaderMRC ParticlesHeader = new HeaderMRC
            //{
            //    PixelSize = new float3(PixelSize, PixelSize, PixelSize)
            //};

            //AverageParticles.WriteMRC(ParticlesPath);
            //AverageParticles.Dispose();

            ////AveragePS.WriteMRC(ParticleCTFPath, ParticlesHeader);
            //AveragePS.Dispose();

            //float[] DistanceWeights = new float[NParticles];
            //for (int p1 = 0; p1 < NParticles - 1; p1++)
            //{
            //    float2 Pos1 = new float2(Origins[p1].X, Origins[p1].Y);

            //    for (int p2 = p1 + 1; p2 < NParticles; p2++)
            //    {
            //        float2 Pos2 = new float2(Origins[p2].X, Origins[p2].Y);
            //        float2 Diff = Pos2 - Pos1;
            //        float Dist = Diff.X * Diff.X + Diff.Y * Diff.Y;
            //        Dist = 1f / Dist;

            //        DistanceWeights[p1] += Dist;
            //        DistanceWeights[p2] += Dist;
            //    }
            //}

            //for (int i = 0; i < NParticles; i++)
            //{
            //    string ParticlePath = (i + 1).ToString("D6") + "@particles/" + RootName + "_particles.mrcs";
            //    tableIn.SetRowValue(RowIndices[i], "rlnImageName", ParticlePath);

            //    //string ParticleCTFsPath = (i + 1).ToString("D6") + "@particlectf/" + RootName + "_particlectf.mrcs";
            //    //tableIn.SetRowValue(RowIndices[i], "rlnCtfImage", ParticleCTFsPath);

            //    tableIn.SetRowValue(RowIndices[i], "rlnAutopickFigureOfMerit", DistanceWeights[i].ToString(CultureInfo.InvariantCulture));
            //}
        }

        public void ExportParticlesMovie(Star tableIn, Star tableOut, MapHeader originalHeader, Image originalStack, int size, float particleradius, decimal scaleFactor)
        {
            //int CurrentDevice = GPU.GetDevice();

            //#region Make sure directories exist.
            //lock (tableIn)
            //{
            //    if (!Directory.Exists(ParticleMoviesDir))
            //        Directory.CreateDirectory(ParticleMoviesDir);
            //    if (!Directory.Exists(ParticleMoviesCTFDir))
            //        Directory.CreateDirectory(ParticleMoviesCTFDir);
            //}
            //#endregion

            //#region Get row indices for all, and individual halves

            //List<int> RowIndices = new List<int>();
            //string[] ColumnMicrographName = tableIn.GetColumn("rlnMicrographName");
            //for (int i = 0; i < ColumnMicrographName.Length; i++)
            //    if (ColumnMicrographName[i].Contains(RootName))
            //        RowIndices.Add(i);

            ////RowIndices = RowIndices.Take(13).ToList();

            //List<int> RowIndices1 = new List<int>();
            //List<int> RowIndices2 = new List<int>();
            //for (int i = 0; i < RowIndices.Count; i++)
            //    if (tableIn.GetRowValue(RowIndices[i], "rlnRandomSubset") == "1")
            //        RowIndices1.Add(RowIndices[i]);
            //    else
            //        RowIndices2.Add(RowIndices[i]);

            //#endregion

            //if (RowIndices.Count == 0)
            //    return;

            //#region Auxiliary variables

            //List<int> TableOutIndices = new List<int>();

            //int3 Dims = originalHeader.Dimensions;
            //Dims.Z = 36;
            //int3 DimsRegion = new int3(size, size, 1);
            //int3 DimsPadded = new int3(size * 2, size * 2, 1);
            //int NParticles = RowIndices.Count;
            //int NParticles1 = RowIndices1.Count;
            //int NParticles2 = RowIndices2.Count;

            //float PixelSize = (float)CTF.PixelSize / 1.00f;
            //float PixelDelta = (float)CTF.PixelSizeDelta / 1.00f;
            //float PixelAngle = (float)CTF.PixelSizeAngle * Helper.ToRad;

            //#endregion

            //#region Prepare initial coordinates and shifts

            //string[] ColumnPosX = tableIn.GetColumn("rlnCoordinateX");
            //string[] ColumnPosY = tableIn.GetColumn("rlnCoordinateY");
            //string[] ColumnOriginX = tableIn.GetColumn("rlnOriginX");
            //string[] ColumnOriginY = tableIn.GetColumn("rlnOriginY");

            //int3[] Origins1 = new int3[NParticles1];
            //int3[] Origins2 = new int3[NParticles2];
            //float3[] ResidualShifts1 = new float3[NParticles1];
            //float3[] ResidualShifts2 = new float3[NParticles2];

            //lock (tableIn)  // Writing to the table, better be on the safe side
            //{
            //    // Half1: Add translational shifts to coordinates, sans the fractional part
            //    for (int i = 0; i < NParticles1; i++)
            //    {
            //        float2 Pos = new float2(float.Parse(ColumnPosX[RowIndices1[i]], CultureInfo.InvariantCulture),
            //                                float.Parse(ColumnPosY[RowIndices1[i]], CultureInfo.InvariantCulture)) * 1.00f;
            //        float2 Shift = new float2(float.Parse(ColumnOriginX[RowIndices1[i]], CultureInfo.InvariantCulture),
            //                                  float.Parse(ColumnOriginY[RowIndices1[i]], CultureInfo.InvariantCulture)) * 1.00f;

            //        Origins1[i] = new int3((int)(Pos.X - Shift.X),
            //                               (int)(Pos.Y - Shift.Y),
            //                               0);
            //        ResidualShifts1[i] = new float3(-MathHelper.ResidualFraction(Pos.X - Shift.X),
            //                                        -MathHelper.ResidualFraction(Pos.Y - Shift.Y),
            //                                        0f);

            //        tableIn.SetRowValue(RowIndices1[i], "rlnCoordinateX", Origins1[i].X.ToString());
            //        tableIn.SetRowValue(RowIndices1[i], "rlnCoordinateY", Origins1[i].Y.ToString());
            //        tableIn.SetRowValue(RowIndices1[i], "rlnOriginX", "0.0");
            //        tableIn.SetRowValue(RowIndices1[i], "rlnOriginY", "0.0");
            //    }

            //    // Half2: Add translational shifts to coordinates, sans the fractional part
            //    for (int i = 0; i < NParticles2; i++)
            //    {
            //        float2 Pos = new float2(float.Parse(ColumnPosX[RowIndices2[i]], CultureInfo.InvariantCulture),
            //                                float.Parse(ColumnPosY[RowIndices2[i]], CultureInfo.InvariantCulture)) * 1.00f;
            //        float2 Shift = new float2(float.Parse(ColumnOriginX[RowIndices2[i]], CultureInfo.InvariantCulture),
            //                                  float.Parse(ColumnOriginY[RowIndices2[i]], CultureInfo.InvariantCulture)) * 1.00f;

            //        Origins2[i] = new int3((int)(Pos.X - Shift.X),
            //                               (int)(Pos.Y - Shift.Y),
            //                               0);
            //        ResidualShifts2[i] = new float3(-MathHelper.ResidualFraction(Pos.X - Shift.X),
            //                                        -MathHelper.ResidualFraction(Pos.Y - Shift.Y),
            //                                        0f);

            //        tableIn.SetRowValue(RowIndices2[i], "rlnCoordinateX", Origins2[i].X.ToString());
            //        tableIn.SetRowValue(RowIndices2[i], "rlnCoordinateY", Origins2[i].Y.ToString());
            //        tableIn.SetRowValue(RowIndices2[i], "rlnOriginX", "0.0");
            //        tableIn.SetRowValue(RowIndices2[i], "rlnOriginY", "0.0");
            //    }
            //}

            //#endregion

            //#region Allocate memory for particle and PS stacks

            //Image ParticleStackAll = new Image(new int3(DimsRegion.X, DimsRegion.Y, NParticles * Dims.Z));
            //Image ParticleStack1 = new Image(new int3(DimsRegion.X, DimsRegion.Y, NParticles1 * Dims.Z));
            //Image ParticleStack2 = new Image(new int3(DimsRegion.X, DimsRegion.Y, NParticles2 * Dims.Z));
            //Image PSStackAll = new Image(new int3(DimsRegion.X, DimsRegion.Y, NParticles * Dims.Z), true);
            //Image PSStack1 = new Image(new int3(DimsRegion.X, DimsRegion.Y, NParticles1 * Dims.Z), true);
            //Image PSStack2 = new Image(new int3(DimsRegion.X, DimsRegion.Y, NParticles2 * Dims.Z), true);

            //Image FrameParticles1 = new Image(IntPtr.Zero, new int3(DimsPadded.X, DimsPadded.Y, NParticles1));
            //Image FrameParticles2 = new Image(IntPtr.Zero, new int3(DimsPadded.X, DimsPadded.Y, NParticles2));

            //float[][] ParticleStackData = ParticleStackAll.GetHost(Intent.Write);
            //float[][] ParticleStackData1 = ParticleStack1.GetHost(Intent.Write);
            //float[][] ParticleStackData2 = ParticleStack2.GetHost(Intent.Write);
            //float[][] PSStackData = PSStackAll.GetHost(Intent.Write);
            //float[][] PSStackData1 = PSStack1.GetHost(Intent.Write);
            //float[][] PSStackData2 = PSStack2.GetHost(Intent.Write);

            //#endregion

            //#region Create rows in outTable

            //lock (tableOut)  // Creating rows in outTable, this absolutely needs to be staged sequentially
            //{
            //    for (int z = 0; z < Dims.Z; z++)
            //    {
            //        for (int i = 0; i < NParticles; i++)
            //        {
            //            int Index = i < NParticles1 ? RowIndices1[i] : RowIndices2[i - NParticles1];

            //            string OriParticlePath = (i + 1).ToString("D6") + "@particles/" + RootName + "_particles.mrcs";
            //            string ParticleName = (z * NParticles + i + 1).ToString("D6") + "@particlemovies/" + RootName + "_particles.mrcs";
            //            string ParticleCTFName = (z * NParticles + i + 1).ToString("D6") + "@particlectfmovies/" + RootName + "_particlectf.mrcs";

            //            List<string> NewRow = tableIn.GetRow(Index).Select(v => v).ToList(); // Get copy of original row.
            //            NewRow[tableOut.GetColumnIndex("rlnOriginalParticleName")] = OriParticlePath;
            //            NewRow[tableOut.GetColumnIndex("rlnAngleRotPrior")] = tableIn.GetRowValue(Index, "rlnAngleRot");
            //            NewRow[tableOut.GetColumnIndex("rlnAngleTiltPrior")] = tableIn.GetRowValue(Index, "rlnAngleTilt");
            //            NewRow[tableOut.GetColumnIndex("rlnAnglePsiPrior")] = tableIn.GetRowValue(Index, "rlnAnglePsi");
            //            NewRow[tableOut.GetColumnIndex("rlnOriginXPrior")] = "0.0";
            //            NewRow[tableOut.GetColumnIndex("rlnOriginYPrior")] = "0.0";

            //            NewRow[tableOut.GetColumnIndex("rlnImageName")] = ParticleName;
            //            NewRow[tableOut.GetColumnIndex("rlnCtfImage")] = ParticleCTFName;
            //            NewRow[tableOut.GetColumnIndex("rlnMicrographName")] = (z + 1).ToString("D6") + "@stack/" + RootName + "_movie.mrcs";

            //            TableOutIndices.Add(tableOut.RowCount);
            //            tableOut.AddRow(NewRow);
            //        }
            //    }
            //}

            //#endregion

            //#region For every frame, extract particles from each half; shift, correct, and norm them

            //float StepZ = 1f / Math.Max(Dims.Z - 1, 1);
            //for (int z = 0; z < Dims.Z; z++)
            //{
            //    float CoordZ = z * StepZ;

            //    #region Extract, correct, and norm particles

            //    #region Half 1
            //    {
            //        if (originalStack != null)
            //            GPU.Extract(originalStack.GetDeviceSlice(z, Intent.Read),
            //                        FrameParticles1.GetDevice(Intent.Write),
            //                        Dims.Slice(),
            //                        DimsPadded,
            //                        Helper.ToInterleaved(Origins1.Select(v => new int3(v.X - DimsPadded.X / 2, v.Y - DimsPadded.Y / 2, 0)).ToArray()),
            //                        (uint)NParticles1);

            //        // Shift particles
            //        {
            //            float3[] Shifts = new float3[NParticles1];

            //            for (int i = 0; i < NParticles1; i++)
            //            {
            //                float3 Coords = new float3((float)Origins1[i].X / Dims.X, (float)Origins1[i].Y / Dims.Y, CoordZ);
            //                Shifts[i] = ResidualShifts1[i] + new float3(GetShiftFromPyramid(Coords)) * 1.00f;
            //            }
            //            FrameParticles1.ShiftSlices(Shifts);
            //        }

            //        Image FrameParticlesCropped = FrameParticles1.AsPadded(new int2(DimsRegion));
            //        Image FrameParticlesCorrected = FrameParticlesCropped.AsAnisotropyCorrected(new int2(DimsRegion),
            //                                                                                    PixelSize + PixelDelta / 2f,
            //                                                                                    PixelSize - PixelDelta / 2f,
            //                                                                                    PixelAngle,
            //                                                                                    6);
            //        FrameParticlesCropped.Dispose();

            //        GPU.NormParticles(FrameParticlesCorrected.GetDevice(Intent.Read),
            //                          FrameParticlesCorrected.GetDevice(Intent.Write),
            //                          DimsRegion,
            //                          (uint)(particleradius / PixelSize),
            //                          true,
            //                          (uint)NParticles1);

            //        float[][] FrameParticlesCorrectedData = FrameParticlesCorrected.GetHost(Intent.Read);
            //        for (int n = 0; n < NParticles1; n++)
            //        {
            //            ParticleStackData[z * NParticles + n] = FrameParticlesCorrectedData[n];
            //            ParticleStackData1[z * NParticles1 + n] = FrameParticlesCorrectedData[n];
            //        }

            //        //FrameParticlesCorrected.WriteMRC("intermediate_particles1.mrc");

            //        FrameParticlesCorrected.Dispose();
            //    }
            //    #endregion

            //    #region Half 2
            //    {
            //        if (originalStack != null)
            //            GPU.Extract(originalStack.GetDeviceSlice(z, Intent.Read),
            //                        FrameParticles2.GetDevice(Intent.Write),
            //                        Dims.Slice(),
            //                        DimsPadded,
            //                        Helper.ToInterleaved(Origins2.Select(v => new int3(v.X - DimsPadded.X / 2, v.Y - DimsPadded.Y / 2, 0)).ToArray()),
            //                        (uint)NParticles2);

            //        // Shift particles
            //        {
            //            float3[] Shifts = new float3[NParticles2];

            //            for (int i = 0; i < NParticles2; i++)
            //            {
            //                float3 Coords = new float3((float)Origins2[i].X / Dims.X, (float)Origins2[i].Y / Dims.Y, CoordZ);
            //                Shifts[i] = ResidualShifts2[i] + new float3(GetShiftFromPyramid(Coords)) * 1.00f;
            //            }
            //            FrameParticles2.ShiftSlices(Shifts);
            //        }

            //        Image FrameParticlesCropped = FrameParticles2.AsPadded(new int2(DimsRegion));
            //        Image FrameParticlesCorrected = FrameParticlesCropped.AsAnisotropyCorrected(new int2(DimsRegion),
            //                                                                                    PixelSize + PixelDelta / 2f,
            //                                                                                    PixelSize - PixelDelta / 2f,
            //                                                                                    PixelAngle,
            //                                                                                    6);
            //        FrameParticlesCropped.Dispose();

            //        GPU.NormParticles(FrameParticlesCorrected.GetDevice(Intent.Read),
            //                          FrameParticlesCorrected.GetDevice(Intent.Write),
            //                          DimsRegion,
            //                          (uint)(particleradius / PixelSize),
            //                          true,
            //                          (uint)NParticles2);

            //        float[][] FrameParticlesCorrectedData = FrameParticlesCorrected.GetHost(Intent.Read);
            //        for (int n = 0; n < NParticles2; n++)
            //        {
            //            ParticleStackData[z * NParticles + NParticles1 + n] = FrameParticlesCorrectedData[n];
            //            ParticleStackData2[z * NParticles2 + n] = FrameParticlesCorrectedData[n];
            //        }

            //        //FrameParticlesCorrected.WriteMRC("intermediate_particles2.mrc");

            //        FrameParticlesCorrected.Dispose();
            //    }
            //    #endregion

            //    #endregion
                
            //    #region PS Half 1
            //    {
            //        Image PS = new Image(new int3(DimsRegion.X, DimsRegion.Y, NParticles1), true);
            //        PS.Fill(1f);

            //        // Apply motion blur filter.

            //        #region Motion blur weighting

            //        {
            //            const int Samples = 11;
            //            float StartZ = (z - 0.5f) * StepZ;
            //            float StopZ = (z + 0.5f) * StepZ;

            //            float2[] Shifts = new float2[Samples * NParticles1];
            //            for (int p = 0; p < NParticles1; p++)
            //            {
            //                float NormX = (float)Origins1[p].X / Dims.X;
            //                float NormY = (float)Origins1[p].Y / Dims.Y;

            //                for (int zz = 0; zz < Samples; zz++)
            //                {
            //                    float zp = StartZ + (StopZ - StartZ) / (Samples - 1) * zz;
            //                    float3 Coords = new float3(NormX, NormY, zp);
            //                    Shifts[p * Samples + zz] = GetShiftFromPyramid(Coords) * 1.00f;
            //                }
            //            }

            //            Image MotionFilter = new Image(IntPtr.Zero, new int3(DimsRegion.X, DimsRegion.Y, NParticles1), true);
            //            GPU.CreateMotionBlur(MotionFilter.GetDevice(Intent.Write),
            //                                 DimsRegion,
            //                                 Helper.ToInterleaved(Shifts.Select(v => new float3(v.X, v.Y, 0)).ToArray()),
            //                                 Samples,
            //                                 (uint)NParticles1);
            //            PS.Multiply(MotionFilter);
            //            //MotionFilter.WriteMRC("motion.mrc");
            //            MotionFilter.Dispose();
            //        }

            //        #endregion

            //        float[][] PSData = PS.GetHost(Intent.Read);
            //        for (int n = 0; n < NParticles1; n++)
            //            PSStackData[z * NParticles + n] = PSData[n];

            //        //PS.WriteMRC("intermediate_ps1.mrc");

            //        PS.Dispose();
            //    }
            //    #endregion

            //    #region PS Half 2
            //    {
            //        Image PS = new Image(new int3(DimsRegion.X, DimsRegion.Y, NParticles2), true);
            //        PS.Fill(1f);

            //        // Apply motion blur filter.

            //        #region Motion blur weighting

            //        {
            //            const int Samples = 11;
            //            float StartZ = (z - 0.5f) * StepZ;
            //            float StopZ = (z + 0.5f) * StepZ;

            //            float2[] Shifts = new float2[Samples * NParticles2];
            //            for (int p = 0; p < NParticles2; p++)
            //            {
            //                float NormX = (float)Origins2[p].X / Dims.X;
            //                float NormY = (float)Origins2[p].Y / Dims.Y;

            //                for (int zz = 0; zz < Samples; zz++)
            //                {
            //                    float zp = StartZ + (StopZ - StartZ) / (Samples - 1) * zz;
            //                    float3 Coords = new float3(NormX, NormY, zp);
            //                    Shifts[p * Samples + zz] = GetShiftFromPyramid(Coords) * 1.00f;
            //                }
            //            }

            //            Image MotionFilter = new Image(IntPtr.Zero, new int3(DimsRegion.X, DimsRegion.Y, NParticles2), true);
            //            GPU.CreateMotionBlur(MotionFilter.GetDevice(Intent.Write),
            //                                 DimsRegion,
            //                                 Helper.ToInterleaved(Shifts.Select(v => new float3(v.X, v.Y, 0)).ToArray()),
            //                                 Samples,
            //                                 (uint)NParticles2);
            //            PS.Multiply(MotionFilter);
            //            //MotionFilter.WriteMRC("motion.mrc");
            //            MotionFilter.Dispose();
            //        }

            //        #endregion

            //        float[][] PSData = PS.GetHost(Intent.Read);
            //        for (int n = 0; n < NParticles2; n++)
            //            PSStackData[z * NParticles + NParticles1 + n] = PSData[n];

            //        //PS.WriteMRC("intermediate_ps2.mrc");

            //        PS.Dispose();
            //    }
            //    #endregion
            //}
            //FrameParticles1.Dispose();
            //FrameParticles2.Dispose();
            //originalStack.FreeDevice();

            //#endregion

            //HeaderMRC ParticlesHeader = new HeaderMRC
            //{
            //    PixelSize = new float3(PixelSize, PixelSize, PixelSize)
            //};

            //// Do translation and rotation BFGS per particle
            //{
            //    float MaxHigh = 2.6f;

            //    CubicGrid GridX = new CubicGrid(new int3(NParticles1, 1, 2));
            //    CubicGrid GridY = new CubicGrid(new int3(NParticles1, 1, 2));
            //    CubicGrid GridRot = new CubicGrid(new int3(NParticles1, 1, 2));
            //    CubicGrid GridTilt = new CubicGrid(new int3(NParticles1, 1, 2));
            //    CubicGrid GridPsi = new CubicGrid(new int3(NParticles1, 1, 2));

            //    int2 DimsCropped = new int2(DimsRegion / (MaxHigh / PixelSize / 2f)) / 2 * 2;

            //    #region Get coordinates for CTF and Fourier-space shifts
            //    Image CTFCoords;
            //    Image ShiftFactors;
            //    {
            //        float2[] CTFCoordsData = new float2[(DimsCropped.X / 2 + 1) * DimsCropped.Y];
            //        float2[] ShiftFactorsData = new float2[(DimsCropped.X / 2 + 1) * DimsCropped.Y];
            //        for (int y = 0; y < DimsCropped.Y; y++)
            //            for (int x = 0; x < DimsCropped.X / 2 + 1; x++)
            //            {
            //                int xx = x;
            //                int yy = y < DimsCropped.Y / 2 + 1 ? y : y - DimsCropped.Y;

            //                float xs = xx / (float)DimsRegion.X;
            //                float ys = yy / (float)DimsRegion.Y;
            //                float r = (float)Math.Sqrt(xs * xs + ys * ys);
            //                float angle = (float)(Math.Atan2(yy, xx));

            //                CTFCoordsData[y * (DimsCropped.X / 2 + 1) + x] = new float2(r / PixelSize, angle);
            //                ShiftFactorsData[y * (DimsCropped.X / 2 + 1) + x] = new float2((float)-xx / DimsRegion.X * 2f * (float)Math.PI,
            //                                                                              (float)-yy / DimsRegion.X * 2f * (float)Math.PI);
            //            }

            //        CTFCoords = new Image(CTFCoordsData, new int3(DimsCropped), true);
            //        ShiftFactors = new Image(ShiftFactorsData, new int3(DimsCropped), true);
            //    }
            //    #endregion

            //    #region Get inverse sigma2 spectrum for this micrograph from Relion's model.star
            //    Image Sigma2Noise = new Image(new int3(DimsCropped), true);
            //    {
            //        int GroupNumber = int.Parse(tableIn.GetRowValue(RowIndices[0], "rlnGroupNumber"));
            //        //Star SigmaTable = new Star("D:\\rado27\\Refine3D\\run1_ct5_it009_half1_model.star", "data_model_group_" + GroupNumber);
            //        Star SigmaTable = new Star(MainWindow.Options.ModelStarPath, "data_model_group_" + GroupNumber);
            //        float[] SigmaValues = SigmaTable.GetColumn("rlnSigma2Noise").Select(v => float.Parse(v)).ToArray();

            //        float[] Sigma2NoiseData = Sigma2Noise.GetHost(Intent.Write)[0];
            //        Helper.ForEachElementFT(DimsCropped, (x, y, xx, yy, r, angle) =>
            //        {
            //            int ir = (int)r;
            //            float val = 0;
            //            if (ir < SigmaValues.Length && ir >= size / (50f / PixelSize) && ir < DimsCropped.X / 2)
            //            {
            //                if (SigmaValues[ir] != 0f)
            //                    val = 1f / SigmaValues[ir];
            //            }
            //            Sigma2NoiseData[y * (DimsCropped.X / 2 + 1) + x] = val;
            //        });
            //        float MaxSigma = MathHelper.Max(Sigma2NoiseData);
            //        for (int i = 0; i < Sigma2NoiseData.Length; i++)
            //            Sigma2NoiseData[i] /= MaxSigma;

            //        Sigma2Noise.RemapToFT();
            //    }
            //    //Sigma2Noise.WriteMRC("d_sigma2noise.mrc");
            //    #endregion

            //    #region Initialize particle angles for both halves

            //    float3[] ParticleAngles1 = new float3[NParticles1];
            //    float3[] ParticleAngles2 = new float3[NParticles2];
            //    for (int p = 0; p < NParticles1; p++)
            //        ParticleAngles1[p] = new float3(float.Parse(tableIn.GetRowValue(RowIndices1[p], "rlnAngleRot")),
            //                                        float.Parse(tableIn.GetRowValue(RowIndices1[p], "rlnAngleTilt")),
            //                                        float.Parse(tableIn.GetRowValue(RowIndices1[p], "rlnAnglePsi")));
            //    for (int p = 0; p < NParticles2; p++)
            //        ParticleAngles2[p] = new float3(float.Parse(tableIn.GetRowValue(RowIndices2[p], "rlnAngleRot")),
            //                                        float.Parse(tableIn.GetRowValue(RowIndices2[p], "rlnAngleTilt")),
            //                                        float.Parse(tableIn.GetRowValue(RowIndices2[p], "rlnAnglePsi")));
            //    #endregion

            //    #region Prepare masks
            //    Image Masks1, Masks2;
            //    {
            //        // Half 1
            //        {
            //            Image Volume = StageDataLoad.LoadMap(MainWindow.Options.MaskPath, new int2(1, 1), 0, typeof (float));
            //            Image VolumePadded = Volume.AsPadded(Volume.Dims * MainWindow.Options.ProjectionOversample);
            //            Volume.Dispose();
            //            VolumePadded.RemapToFT(true);
            //            Image VolMaskFT = VolumePadded.AsFFT(true);
            //            VolumePadded.Dispose();

            //            Image MasksFT = VolMaskFT.AsProjections(ParticleAngles1.Select(v => new float3(v.X * Helper.ToRad, v.Y * Helper.ToRad, v.Z * Helper.ToRad)).ToArray(),
            //                                                    new int2(DimsRegion),
            //                                                    MainWindow.Options.ProjectionOversample);
            //            VolMaskFT.Dispose();

            //            Masks1 = MasksFT.AsIFFT();
            //            MasksFT.Dispose();

            //            Masks1.RemapFromFT();

            //            Parallel.ForEach(Masks1.GetHost(Intent.ReadWrite), slice =>
            //            {
            //                for (int i = 0; i < slice.Length; i++)
            //                    slice[i] = (Math.Max(2f, Math.Min(50f, slice[i])) - 2) / 48f;
            //            });
            //        }

            //        // Half 2
            //        {
            //            Image Volume = StageDataLoad.LoadMap(MainWindow.Options.MaskPath, new int2(1, 1), 0, typeof(float));
            //            Image VolumePadded = Volume.AsPadded(Volume.Dims * MainWindow.Options.ProjectionOversample);
            //            Volume.Dispose();
            //            VolumePadded.RemapToFT(true);
            //            Image VolMaskFT = VolumePadded.AsFFT(true);
            //            VolumePadded.Dispose();

            //            Image MasksFT = VolMaskFT.AsProjections(ParticleAngles2.Select(v => new float3(v.X * Helper.ToRad, v.Y * Helper.ToRad, v.Z * Helper.ToRad)).ToArray(),
            //                                                    new int2(DimsRegion),
            //                                                    MainWindow.Options.ProjectionOversample);
            //            VolMaskFT.Dispose();

            //            Masks2 = MasksFT.AsIFFT();
            //            MasksFT.Dispose();

            //            Masks2.RemapFromFT();

            //            Parallel.ForEach(Masks2.GetHost(Intent.ReadWrite), slice =>
            //            {
            //                for (int i = 0; i < slice.Length; i++)
            //                    slice[i] = (Math.Max(2f, Math.Min(50f, slice[i])) - 2) / 48f;
            //            });
            //        }
            //    }
            //    //Masks1.WriteMRC("d_masks1.mrc");
            //    //Masks2.WriteMRC("d_masks2.mrc");
            //    #endregion

            //    #region Load and prepare references for both halves
            //    Image VolRefFT1;
            //    {
            //        Image Volume = StageDataLoad.LoadMap(MainWindow.Options.ReferencePath, new int2(1, 1), 0, typeof(float));
            //        //GPU.Normalize(Volume.GetDevice(Intent.Read), Volume.GetDevice(Intent.Write), (uint)Volume.ElementsReal, 1);
            //        Image VolumePadded = Volume.AsPadded(Volume.Dims * MainWindow.Options.ProjectionOversample);
            //        Volume.Dispose();
            //        VolumePadded.RemapToFT(true);
            //        VolRefFT1 = VolumePadded.AsFFT(true);
            //        VolumePadded.Dispose();
            //    }
            //    VolRefFT1.FreeDevice();

            //    Image VolRefFT2;
            //    {
            //        // Can't assume there is a second half, but certainly hope so
            //        string Half2Path = MainWindow.Options.ReferencePath;
            //        if (Half2Path.Contains("half1"))
            //            Half2Path = Half2Path.Replace("half1", "half2");

            //        Image Volume = StageDataLoad.LoadMap(Half2Path, new int2(1, 1), 0, typeof(float));
            //        //GPU.Normalize(Volume.GetDevice(Intent.Read), Volume.GetDevice(Intent.Write), (uint)Volume.ElementsReal, 1);
            //        Image VolumePadded = Volume.AsPadded(Volume.Dims * MainWindow.Options.ProjectionOversample);
            //        Volume.Dispose();
            //        VolumePadded.RemapToFT(true);
            //        VolRefFT2 = VolumePadded.AsFFT(true);
            //        VolumePadded.Dispose();
            //    }
            //    VolRefFT2.FreeDevice();
            //    #endregion

            //    #region Prepare particles: group and resize to DimsCropped

            //    Image ParticleStackFT1 = new Image(IntPtr.Zero, new int3(DimsCropped.X, DimsCropped.Y, NParticles1 * Dims.Z / 3), true, true);
            //    {
            //        GPU.CreatePolishing(ParticleStack1.GetDevice(Intent.Read),
            //                            ParticleStackFT1.GetDevice(Intent.Write),
            //                            Masks1.GetDevice(Intent.Read),
            //                            new int2(DimsRegion),
            //                            DimsCropped,
            //                            NParticles1,
            //                            Dims.Z);

            //        ParticleStack1.FreeDevice();
            //        Masks1.Dispose();

            //        /*Image Amps = ParticleStackFT1.AsIFFT();
            //        Amps.RemapFromFT();
            //        Amps.WriteMRC("d_particlestackft1.mrc");
            //        Amps.Dispose();*/
            //    }

            //    Image ParticleStackFT2 = new Image(IntPtr.Zero, new int3(DimsCropped.X, DimsCropped.Y, NParticles2 * Dims.Z / 3), true, true);
            //    {
            //        GPU.CreatePolishing(ParticleStack2.GetDevice(Intent.Read),
            //                            ParticleStackFT2.GetDevice(Intent.Write),
            //                            Masks2.GetDevice(Intent.Read),
            //                            new int2(DimsRegion),
            //                            DimsCropped,
            //                            NParticles2,
            //                            Dims.Z);

            //        ParticleStack1.FreeDevice();
            //        Masks2.Dispose();

            //        /*Image Amps = ParticleStackFT2.AsIFFT();
            //        Amps.RemapFromFT();
            //        Amps.WriteMRC("d_particlestackft2.mrc");
            //        Amps.Dispose();*/
            //    }
            //    #endregion

            //    Image Projections1 = new Image(IntPtr.Zero, new int3(DimsCropped.X, DimsCropped.Y, NParticles1 * Dims.Z / 3), true, true);
            //    Image Projections2 = new Image(IntPtr.Zero, new int3(DimsCropped.X, DimsCropped.Y, NParticles2 * Dims.Z / 3), true, true);

            //    Image Shifts1 = new Image(new int3(NParticles1, Dims.Z / 3, 1), false, true);
            //    float3[] Angles1 = new float3[NParticles1 * Dims.Z / 3];
            //    CTFStruct[] CTFParams1 = new CTFStruct[NParticles1 * Dims.Z / 3];

            //    Image Shifts2 = new Image(new int3(NParticles2, Dims.Z / 3, 1), false, true);
            //    float3[] Angles2 = new float3[NParticles2 * Dims.Z / 3];
            //    CTFStruct[] CTFParams2 = new CTFStruct[NParticles2 * Dims.Z / 3];

            //    float[] BFacs =
            //    {
            //        -3.86f,
            //        0.00f,
            //        -17.60f,
            //        -35.24f,
            //        -57.48f,
            //        -93.51f,
            //        -139.57f,
            //        -139.16f
            //    };

            //    #region Initialize defocus and phase shift values
            //    float[] InitialDefoci1 = new float[NParticles1 * (Dims.Z / 3)];
            //    float[] InitialPhaseShifts1 = new float[NParticles1 * (Dims.Z / 3)];
            //    float[] InitialDefoci2 = new float[NParticles2 * (Dims.Z / 3)];
            //    float[] InitialPhaseShifts2 = new float[NParticles2 * (Dims.Z / 3)];
            //    for (int z = 0, i = 0; z < Dims.Z / 3; z++)
            //    {
            //        for (int p = 0; p < NParticles1; p++, i++)
            //        {
            //            InitialDefoci1[i] = GridCTF.GetInterpolated(new float3((float)Origins1[p].X / Dims.X,
            //                                                                   (float)Origins1[p].Y / Dims.Y,
            //                                                                   (float)(z * 3 + 1) / (Dims.Z - 1)));
            //            InitialPhaseShifts1[i] = GridCTFPhase.GetInterpolated(new float3((float)Origins1[p].X / Dims.X,
            //                                                                             (float)Origins1[p].Y / Dims.Y,
            //                                                                             (float)(z * 3 + 1) / (Dims.Z - 1)));

            //            CTF Alt = CTF.GetCopy();
            //            Alt.PixelSize = (decimal)PixelSize;
            //            Alt.PixelSizeDelta = 0;
            //            Alt.Defocus = (decimal)InitialDefoci1[i];
            //            Alt.PhaseShift = (decimal)InitialPhaseShifts1[i];
            //            //Alt.Bfactor = (decimal)BFacs[z];

            //            CTFParams1[i] = Alt.ToStruct();
            //        }
            //    }
            //    for (int z = 0, i = 0; z < Dims.Z / 3; z++)
            //    {
            //        for (int p = 0; p < NParticles2; p++, i++)
            //        {
            //            InitialDefoci2[i] = GridCTF.GetInterpolated(new float3((float)Origins2[p].X / Dims.X,
            //                                                                   (float)Origins2[p].Y / Dims.Y,
            //                                                                   (float)(z * 3 + 1) / (Dims.Z - 1)));
            //            InitialPhaseShifts2[i] = GridCTFPhase.GetInterpolated(new float3((float)Origins2[p].X / Dims.X,
            //                                                                             (float)Origins2[p].Y / Dims.Y,
            //                                                                             (float)(z * 3 + 1) / (Dims.Z - 1)));

            //            CTF Alt = CTF.GetCopy();
            //            Alt.PixelSize = (decimal)PixelSize;
            //            Alt.PixelSizeDelta = 0;
            //            Alt.Defocus = (decimal)InitialDefoci2[i];
            //            Alt.PhaseShift = (decimal)InitialPhaseShifts2[i];
            //            //Alt.Bfactor = (decimal)BFacs[z];

            //            CTFParams2[i] = Alt.ToStruct();
            //        }
            //    }
            //    #endregion

            //    #region SetPositions lambda
            //    Action<double[]> SetPositions = input =>
            //    {
            //        float BorderZ = 0.5f / (Dims.Z / 3);

            //        GridX = new CubicGrid(new int3(NParticles, 1, 2), input.Take(NParticles * 2).Select(v => (float)v).ToArray());
            //        GridY = new CubicGrid(new int3(NParticles, 1, 2), input.Skip(NParticles * 2 * 1).Take(NParticles * 2).Select(v => (float)v).ToArray());

            //        float[] AlteredX = GridX.GetInterpolatedNative(new int3(NParticles, 1, Dims.Z / 3), new float3(0, 0, BorderZ));
            //        float[] AlteredY = GridY.GetInterpolatedNative(new int3(NParticles, 1, Dims.Z / 3), new float3(0, 0, BorderZ));

            //        GridRot = new CubicGrid(new int3(NParticles, 1, 2), input.Skip(NParticles * 2 * 2).Take(NParticles * 2).Select(v => (float)v).ToArray());
            //        GridTilt = new CubicGrid(new int3(NParticles, 1, 2), input.Skip(NParticles * 2 * 3).Take(NParticles * 2).Select(v => (float)v).ToArray());
            //        GridPsi = new CubicGrid(new int3(NParticles, 1, 2), input.Skip(NParticles * 2 * 4).Take(NParticles * 2).Select(v => (float)v).ToArray());

            //        float[] AlteredRot = GridRot.GetInterpolatedNative(new int3(NParticles, 1, Dims.Z / 3), new float3(0, 0, BorderZ));
            //        float[] AlteredTilt = GridTilt.GetInterpolatedNative(new int3(NParticles, 1, Dims.Z / 3), new float3(0, 0, BorderZ));
            //        float[] AlteredPsi = GridPsi.GetInterpolatedNative(new int3(NParticles, 1, Dims.Z / 3), new float3(0, 0, BorderZ));

            //        float[] ShiftData1 = Shifts1.GetHost(Intent.Write)[0];
            //        float[] ShiftData2 = Shifts2.GetHost(Intent.Write)[0];

            //        for (int z = 0; z < Dims.Z / 3; z++)
            //        {
            //            // Half 1
            //            for (int p = 0; p < NParticles1; p++)
            //            {
            //                int i1 = z * NParticles1 + p;
            //                int i = z * NParticles + p;
            //                ShiftData1[i1 * 2] = AlteredX[i];
            //                ShiftData1[i1 * 2 + 1] = AlteredY[i];

            //                Angles1[i1] = new float3(AlteredRot[i] * 1f * Helper.ToRad, AlteredTilt[i] * 1f * Helper.ToRad, AlteredPsi[i] * 1f * Helper.ToRad);
            //            }

            //            // Half 2
            //            for (int p = 0; p < NParticles2; p++)
            //            {
            //                int i2 = z * NParticles2 + p;
            //                int i = z * NParticles + NParticles1 + p;
            //                ShiftData2[i2 * 2] = AlteredX[i];
            //                ShiftData2[i2 * 2 + 1] = AlteredY[i];

            //                Angles2[i2] = new float3(AlteredRot[i] * 1f * Helper.ToRad, AlteredTilt[i] * 1f * Helper.ToRad, AlteredPsi[i] * 1f * Helper.ToRad);
            //            }
            //        }
            //    };
            //    #endregion

            //    #region EvalIndividuals lambda
            //    Func<double[], bool, double[]> EvalIndividuals = (input, redoProj) =>
            //    {
            //        SetPositions(input);

            //        if (redoProj)
            //        {
            //            GPU.ProjectForward(VolRefFT1.GetDevice(Intent.Read),
            //                               Projections1.GetDevice(Intent.Write),
            //                               VolRefFT1.Dims,
            //                               DimsCropped,
            //                               Helper.ToInterleaved(Angles1),
            //                               MainWindow.Options.ProjectionOversample,
            //                               (uint)(NParticles1 * Dims.Z / 3));

            //            GPU.ProjectForward(VolRefFT2.GetDevice(Intent.Read),
            //                               Projections2.GetDevice(Intent.Write),
            //                               VolRefFT2.Dims,
            //                               DimsCropped,
            //                               Helper.ToInterleaved(Angles2),
            //                               MainWindow.Options.ProjectionOversample,
            //                               (uint)(NParticles2 * Dims.Z / 3));
            //        }

            //        /*{
            //            Image ProjectionsAmps = Projections1.AsIFFT();
            //            ProjectionsAmps.RemapFromFT();
            //            ProjectionsAmps.WriteMRC("d_projectionsamps1.mrc");
            //            ProjectionsAmps.Dispose();
            //        }
            //        {
            //            Image ProjectionsAmps = Projections2.AsIFFT();
            //            ProjectionsAmps.RemapFromFT();
            //            ProjectionsAmps.WriteMRC("d_projectionsamps2.mrc");
            //            ProjectionsAmps.Dispose();
            //        }*/

            //        float[] Diff1 = new float[NParticles1];
            //        float[] DiffAll1 = new float[NParticles1 * (Dims.Z / 3)];
            //        GPU.PolishingGetDiff(ParticleStackFT1.GetDevice(Intent.Read),
            //                             Projections1.GetDevice(Intent.Read),
            //                             ShiftFactors.GetDevice(Intent.Read),
            //                             CTFCoords.GetDevice(Intent.Read),
            //                             CTFParams1,
            //                             Sigma2Noise.GetDevice(Intent.Read),
            //                             DimsCropped,
            //                             Shifts1.GetDevice(Intent.Read),
            //                             Diff1,
            //                             DiffAll1,
            //                             (uint)NParticles1,
            //                             (uint)Dims.Z / 3);

            //        float[] Diff2 = new float[NParticles2];
            //        float[] DiffAll2 = new float[NParticles2 * (Dims.Z / 3)];
            //        GPU.PolishingGetDiff(ParticleStackFT2.GetDevice(Intent.Read),
            //                             Projections2.GetDevice(Intent.Read),
            //                             ShiftFactors.GetDevice(Intent.Read),
            //                             CTFCoords.GetDevice(Intent.Read),
            //                             CTFParams2,
            //                             Sigma2Noise.GetDevice(Intent.Read),
            //                             DimsCropped,
            //                             Shifts2.GetDevice(Intent.Read),
            //                             Diff2,
            //                             DiffAll2,
            //                             (uint)NParticles2,
            //                             (uint)Dims.Z / 3);

            //        double[] DiffBoth = new double[NParticles];
            //        for (int p = 0; p < NParticles1; p++)
            //            DiffBoth[p] = Diff1[p];
            //        for (int p = 0; p < NParticles2; p++)
            //            DiffBoth[NParticles1 + p] = Diff2[p];

            //        return DiffBoth;
            //    };
            //    #endregion

            //    Func<double[], double> Eval = input =>
            //    {
            //        float Result = MathHelper.Mean(EvalIndividuals(input, true).Select(v => (float)v)) * NParticles;
            //        Debug.WriteLine(Result);
            //        return Result;
            //    };

            //    Func<double[], double[]> Grad = input =>
            //    {
            //        SetPositions(input);

            //        GPU.ProjectForward(VolRefFT1.GetDevice(Intent.Read),
            //                           Projections1.GetDevice(Intent.Write),
            //                           VolRefFT1.Dims,
            //                           DimsCropped,
            //                           Helper.ToInterleaved(Angles1),
            //                           MainWindow.Options.ProjectionOversample,
            //                           (uint)(NParticles1 * Dims.Z / 3));

            //        GPU.ProjectForward(VolRefFT2.GetDevice(Intent.Read),
            //                           Projections2.GetDevice(Intent.Write),
            //                           VolRefFT2.Dims,
            //                           DimsCropped,
            //                           Helper.ToInterleaved(Angles2),
            //                           MainWindow.Options.ProjectionOversample,
            //                           (uint)(NParticles2 * Dims.Z / 3));

            //        double[] Result = new double[input.Length];

            //        double Step = 0.1;
            //        int NVariables = 10;    // (Shift + Euler) * 2
            //        for (int v = 0; v < NVariables; v++)
            //        {
            //            double[] InputPlus = new double[input.Length];
            //            for (int i = 0; i < input.Length; i++)
            //            {
            //                int iv = i / NParticles;

            //                if (iv == v)
            //                    InputPlus[i] = input[i] + Step;
            //                else
            //                    InputPlus[i] = input[i];
            //            }
            //            double[] ScorePlus = EvalIndividuals(InputPlus, v >= 4);

            //            double[] InputMinus = new double[input.Length];
            //            for (int i = 0; i < input.Length; i++)
            //            {
            //                int iv = i / NParticles;

            //                if (iv == v)
            //                    InputMinus[i] = input[i] - Step;
            //                else
            //                    InputMinus[i] = input[i];
            //            }
            //            double[] ScoreMinus = EvalIndividuals(InputMinus, v >= 4);

            //            for (int i = 0; i < NParticles; i++)
            //                Result[v * NParticles + i] = (ScorePlus[i] - ScoreMinus[i]) / (Step * 2.0);
            //        }

            //        return Result;
            //    };

            //    double[] StartParams = new double[NParticles * 2 * 5];
                
            //    for (int i = 0; i < NParticles * 2; i++)
            //    {
            //        int p = i % NParticles;
            //        StartParams[NParticles * 2 * 0 + i] = 0;
            //        StartParams[NParticles * 2 * 1 + i] = 0;

            //        if (p < NParticles1)
            //        {
            //            StartParams[NParticles * 2 * 2 + i] = ParticleAngles1[p].X / 1.0;
            //            StartParams[NParticles * 2 * 3 + i] = ParticleAngles1[p].Y / 1.0;
            //            StartParams[NParticles * 2 * 4 + i] = ParticleAngles1[p].Z / 1.0;
            //        }
            //        else
            //        {
            //            p -= NParticles1;
            //            StartParams[NParticles * 2 * 2 + i] = ParticleAngles2[p].X / 1.0;
            //            StartParams[NParticles * 2 * 3 + i] = ParticleAngles2[p].Y / 1.0;
            //            StartParams[NParticles * 2 * 4 + i] = ParticleAngles2[p].Z / 1.0;
            //        }
            //    }

            //    BroydenFletcherGoldfarbShanno Optimizer = new BroydenFletcherGoldfarbShanno(StartParams.Length, Eval, Grad);
            //    Optimizer.Epsilon = 3e-7;
                
            //    Optimizer.Maximize(StartParams);

            //    #region Calculate particle quality for high frequencies
            //    float[] ParticleQuality = new float[NParticles * (Dims.Z / 3)];
            //    {
            //        Sigma2Noise.Dispose();
            //        Sigma2Noise = new Image(new int3(DimsCropped), true);
            //        {
            //            int GroupNumber = int.Parse(tableIn.GetRowValue(RowIndices[0], "rlnGroupNumber"));
            //            //Star SigmaTable = new Star("D:\\rado27\\Refine3D\\run1_ct5_it009_half1_model.star", "data_model_group_" + GroupNumber);
            //            Star SigmaTable = new Star(MainWindow.Options.ModelStarPath, "data_model_group_" + GroupNumber);
            //            float[] SigmaValues = SigmaTable.GetColumn("rlnSigma2Noise").Select(v => float.Parse(v)).ToArray();

            //            float[] Sigma2NoiseData = Sigma2Noise.GetHost(Intent.Write)[0];
            //            Helper.ForEachElementFT(DimsCropped, (x, y, xx, yy, r, angle) =>
            //            {
            //                int ir = (int)r;
            //                float val = 0;
            //                if (ir < SigmaValues.Length && ir >= size / (4.0f / PixelSize) && ir < DimsCropped.X / 2)
            //                {
            //                    if (SigmaValues[ir] != 0f)
            //                        val = 1f / SigmaValues[ir] / (ir * 3.14f);
            //                }
            //                Sigma2NoiseData[y * (DimsCropped.X / 2 + 1) + x] = val;
            //            });
            //            float MaxSigma = MathHelper.Max(Sigma2NoiseData);
            //            for (int i = 0; i < Sigma2NoiseData.Length; i++)
            //                Sigma2NoiseData[i] /= MaxSigma;

            //            Sigma2Noise.RemapToFT();
            //        }
            //        //Sigma2Noise.WriteMRC("d_sigma2noiseScore.mrc");

            //        SetPositions(StartParams);

            //        GPU.ProjectForward(VolRefFT1.GetDevice(Intent.Read),
            //                           Projections1.GetDevice(Intent.Write),
            //                           VolRefFT1.Dims,
            //                           DimsCropped,
            //                           Helper.ToInterleaved(Angles1),
            //                           MainWindow.Options.ProjectionOversample,
            //                           (uint)(NParticles1 * Dims.Z / 3));

            //        GPU.ProjectForward(VolRefFT2.GetDevice(Intent.Read),
            //                           Projections2.GetDevice(Intent.Write),
            //                           VolRefFT2.Dims,
            //                           DimsCropped,
            //                           Helper.ToInterleaved(Angles2),
            //                           MainWindow.Options.ProjectionOversample,
            //                           (uint)(NParticles2 * Dims.Z / 3));

            //        float[] Diff1 = new float[NParticles1];
            //        float[] ParticleQuality1 = new float[NParticles1 * (Dims.Z / 3)];
            //        GPU.PolishingGetDiff(ParticleStackFT1.GetDevice(Intent.Read),
            //                             Projections1.GetDevice(Intent.Read),
            //                             ShiftFactors.GetDevice(Intent.Read),
            //                             CTFCoords.GetDevice(Intent.Read),
            //                             CTFParams1,
            //                             Sigma2Noise.GetDevice(Intent.Read),
            //                             DimsCropped,
            //                             Shifts1.GetDevice(Intent.Read),
            //                             Diff1,
            //                             ParticleQuality1,
            //                             (uint)NParticles1,
            //                             (uint)Dims.Z / 3);

            //        float[] Diff2 = new float[NParticles2];
            //        float[] ParticleQuality2 = new float[NParticles2 * (Dims.Z / 3)];
            //        GPU.PolishingGetDiff(ParticleStackFT2.GetDevice(Intent.Read),
            //                             Projections2.GetDevice(Intent.Read),
            //                             ShiftFactors.GetDevice(Intent.Read),
            //                             CTFCoords.GetDevice(Intent.Read),
            //                             CTFParams2,
            //                             Sigma2Noise.GetDevice(Intent.Read),
            //                             DimsCropped,
            //                             Shifts2.GetDevice(Intent.Read),
            //                             Diff2,
            //                             ParticleQuality2,
            //                             (uint)NParticles2,
            //                             (uint)Dims.Z / 3);

            //        for (int z = 0; z < Dims.Z / 3; z++)
            //        {
            //            for (int p = 0; p < NParticles1; p++)
            //                ParticleQuality[z * NParticles + p] = ParticleQuality1[z * NParticles1 + p];

            //            for (int p = 0; p < NParticles2; p++)
            //                ParticleQuality[z * NParticles + NParticles1 + p] = ParticleQuality2[z * NParticles2 + p];
            //        }
            //    }
            //    #endregion

            //    lock (tableOut)     // Only changing cell values, but better be safe in case table implementation changes later
            //    {
            //        GridX = new CubicGrid(new int3(NParticles, 1, 2), Optimizer.Solution.Take(NParticles * 2).Select(v => (float)v).ToArray());
            //        GridY = new CubicGrid(new int3(NParticles, 1, 2), Optimizer.Solution.Skip(NParticles * 2 * 1).Take(NParticles * 2).Select(v => (float)v).ToArray());
            //        float[] AlteredX = GridX.GetInterpolated(new int3(NParticles, 1, Dims.Z), new float3(0, 0, 0));
            //        float[] AlteredY = GridY.GetInterpolated(new int3(NParticles, 1, Dims.Z), new float3(0, 0, 0));

            //        GridRot = new CubicGrid(new int3(NParticles, 1, 2), Optimizer.Solution.Skip(NParticles * 2 * 2).Take(NParticles * 2).Select(v => (float)v).ToArray());
            //        GridTilt = new CubicGrid(new int3(NParticles, 1, 2), Optimizer.Solution.Skip(NParticles * 2 * 3).Take(NParticles * 2).Select(v => (float)v).ToArray());
            //        GridPsi = new CubicGrid(new int3(NParticles, 1, 2), Optimizer.Solution.Skip(NParticles * 2 * 4).Take(NParticles * 2).Select(v => (float)v).ToArray());
            //        float[] AlteredRot = GridRot.GetInterpolated(new int3(NParticles, 1, Dims.Z), new float3(0, 0, 0));
            //        float[] AlteredTilt = GridTilt.GetInterpolated(new int3(NParticles, 1, Dims.Z), new float3(0, 0, 0));
            //        float[] AlteredPsi = GridPsi.GetInterpolated(new int3(NParticles, 1, Dims.Z), new float3(0, 0, 0));
                    
            //        for (int i = 0; i < TableOutIndices.Count; i++)
            //        {
            //            int p = i % NParticles;
            //            int z = i / NParticles;
            //            float Defocus = 0, PhaseShift = 0;

            //            if (p < NParticles1)
            //            {
            //                Defocus = GridCTF.GetInterpolated(new float3((float)Origins1[p].X / Dims.X,
            //                                                             (float)Origins1[p].Y / Dims.Y,
            //                                                             (float)z / (Dims.Z - 1)));
            //                PhaseShift = GridCTFPhase.GetInterpolated(new float3((float)Origins1[p].X / Dims.X,
            //                                                                     (float)Origins1[p].Y / Dims.Y,
            //                                                                     (float)z / (Dims.Z - 1)));
            //            }
            //            else
            //            {
            //                p -= NParticles1;
            //                Defocus = GridCTF.GetInterpolated(new float3((float)Origins2[p].X / Dims.X,
            //                                                             (float)Origins2[p].Y / Dims.Y,
            //                                                             (float)z / (Dims.Z - 1)));
            //                PhaseShift = GridCTFPhase.GetInterpolated(new float3((float)Origins2[p].X / Dims.X,
            //                                                                     (float)Origins2[p].Y / Dims.Y,
            //                                                                     (float)z / (Dims.Z - 1)));
            //            }

            //            tableOut.SetRowValue(TableOutIndices[i], "rlnOriginX", AlteredX[i].ToString(CultureInfo.InvariantCulture));
            //            tableOut.SetRowValue(TableOutIndices[i], "rlnOriginY", AlteredY[i].ToString(CultureInfo.InvariantCulture));
            //            tableOut.SetRowValue(TableOutIndices[i], "rlnAngleRot", (-AlteredRot[i]).ToString(CultureInfo.InvariantCulture));
            //            tableOut.SetRowValue(TableOutIndices[i], "rlnAngleTilt", (-AlteredTilt[i]).ToString(CultureInfo.InvariantCulture));
            //            tableOut.SetRowValue(TableOutIndices[i], "rlnAnglePsi", (-AlteredPsi[i]).ToString(CultureInfo.InvariantCulture));
            //            tableOut.SetRowValue(TableOutIndices[i], "rlnDefocusU", ((Defocus + (float)CTF.DefocusDelta / 2f) * 1e4f).ToString(CultureInfo.InvariantCulture));
            //            tableOut.SetRowValue(TableOutIndices[i], "rlnDefocusV", ((Defocus - (float)CTF.DefocusDelta / 2f) * 1e4f).ToString(CultureInfo.InvariantCulture));
            //            tableOut.SetRowValue(TableOutIndices[i], "rlnPhaseShift", (PhaseShift * 180f).ToString(CultureInfo.InvariantCulture));
            //            tableOut.SetRowValue(TableOutIndices[i], "rlnCtfFigureOfMerit", (ParticleQuality[(z / 3) * NParticles + (i % NParticles)]).ToString(CultureInfo.InvariantCulture));

            //            tableOut.SetRowValue(TableOutIndices[i], "rlnMagnification", ((float)MainWindow.Options.CTFDetectorPixel * 10000f / PixelSize).ToString());
            //        }
            //    }

            //    VolRefFT1.Dispose();
            //    VolRefFT2.Dispose();
            //    Projections1.Dispose();
            //    Projections2.Dispose();
            //    Sigma2Noise.Dispose();
            //    ParticleStackFT1.Dispose();
            //    ParticleStackFT2.Dispose();
            //    Shifts1.Dispose();
            //    Shifts2.Dispose();
            //    CTFCoords.Dispose();
            //    ShiftFactors.Dispose();

            //    ParticleStack1.Dispose();
            //    ParticleStack2.Dispose();
            //    PSStack1.Dispose();
            //    PSStack2.Dispose();
            //}
            
            //// Write movies to disk asynchronously, so the next micrograph can load.
            //Thread SaveThread = new Thread(() =>
            //{
            //    GPU.SetDevice(CurrentDevice);   // It's a separate thread, make sure it's using the same device

            //    ParticleStackAll.WriteMRC(ParticleMoviesPath, ParticlesHeader);
            //    //ParticleStackAll.WriteMRC("D:\\gala\\particlemovies\\" + RootName + "_particles.mrcs", ParticlesHeader);
            //    ParticleStackAll.Dispose();

            //    PSStackAll.WriteMRC(ParticleMoviesCTFPath);
            //    //PSStackAll.WriteMRC("D:\\rado27\\particlectfmovies\\" + RootName + "_particlectf.mrcs");
            //    PSStackAll.Dispose();
            //});
            //SaveThread.Start();
        }
    }

    public class ProcessingOptionsMovieCTF : ProcessingOptionsBase
    {
        [WarpSerializable]
        public int Window { get; set; }
        [WarpSerializable]
        public decimal RangeMin { get; set; }
        [WarpSerializable]
        public decimal RangeMax { get; set; }
        [WarpSerializable]
        public int Voltage { get; set; }
        [WarpSerializable]
        public decimal Cs { get; set; }
        [WarpSerializable]
        public decimal Cc { get; set; }
        [WarpSerializable]
        public decimal IllumAngle { get; set; }
        [WarpSerializable]
        public decimal EnergySpread { get; set; }
        [WarpSerializable]
        public decimal Thickness { get; set; }
        [WarpSerializable]
        public decimal Amplitude { get; set; }
        [WarpSerializable]
        public bool DoPhase { get; set; }
        [WarpSerializable]
        public decimal Astigmatism { get; set; }
        [WarpSerializable]
        public decimal AstigmatismAngle { get; set; }
        [WarpSerializable]
        public decimal ZMin { get; set; }
        [WarpSerializable]
        public decimal ZMax { get; set; }
        [WarpSerializable]
        public int3 GridDims { get; set; }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((ProcessingOptionsMovieCTF)obj);
        }

        protected bool Equals(ProcessingOptionsMovieCTF other)
        {
            return PixelSizeX == other.PixelSizeX &&
                   PixelSizeY == other.PixelSizeY &&
                   PixelSizeAngle == other.PixelSizeAngle &&
                   BinTimes == other.BinTimes &&
                   GainPath == other.GainPath &&
                   Window == other.Window &&
                   RangeMin == other.RangeMin &&
                   RangeMax == other.RangeMax &&
                   Voltage == other.Voltage &&
                   Cs == other.Cs &&
                   Cc == other.Cc &&
                   IllumAngle == other.IllumAngle &&
                   EnergySpread == other.EnergySpread &&
                   Thickness == other.Thickness &&
                   Amplitude == other.Amplitude &&
                   DoPhase == other.DoPhase &&
                   Astigmatism == other.Astigmatism &&
                   AstigmatismAngle == other.AstigmatismAngle &&
                   ZMin == other.ZMin &&
                   ZMax == other.ZMax &&
                   GridDims == other.GridDims;
        }

        public static bool operator ==(ProcessingOptionsMovieCTF left, ProcessingOptionsMovieCTF right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(ProcessingOptionsMovieCTF left, ProcessingOptionsMovieCTF right)
        {
            return !Equals(left, right);
        }
    }

    public class ProcessingOptionsMovieMovement : ProcessingOptionsBase
    {
        [WarpSerializable]
        public decimal RangeMin { get; set; }
        [WarpSerializable]
        public decimal RangeMax { get; set; }
        [WarpSerializable]
        public decimal Bfactor { get; set; }
        [WarpSerializable]
        public int3 GridDims { get; set; }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((ProcessingOptionsMovieMovement)obj);
        }

        protected bool Equals(ProcessingOptionsMovieMovement other)
        {
            return PixelSizeX == other.PixelSizeX &&
                   PixelSizeY == other.PixelSizeY &&
                   PixelSizeAngle == other.PixelSizeAngle &&
                   BinTimes == other.BinTimes &&
                   GainPath == other.GainPath &&
                   RangeMin == other.RangeMin &&
                   RangeMax == other.RangeMax &&
                   Bfactor == other.Bfactor &&
                   GridDims == other.GridDims;
        }

        public static bool operator ==(ProcessingOptionsMovieMovement left, ProcessingOptionsMovieMovement right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(ProcessingOptionsMovieMovement left, ProcessingOptionsMovieMovement right)
        {
            return !Equals(left, right);
        }
    }

    public class ProcessingOptionsMovieExport : ProcessingOptionsBase
    {
        [WarpSerializable]
        public bool DoAverage { get; set; }
        [WarpSerializable]
        public bool DoStack { get; set; }
        [WarpSerializable]
        public bool DoDeconv { get; set; }
        [WarpSerializable]
        public int StackGroupSize { get; set; }
        [WarpSerializable]
        public int SkipFirstN { get; set; }
        [WarpSerializable]
        public int SkipLastN { get; set; }
        [WarpSerializable]
        public decimal DosePerAngstromFrame { get; set; }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((ProcessingOptionsMovieExport)obj);
        }

        protected bool Equals(ProcessingOptionsMovieExport other)
        {
            return PixelSizeX == other.PixelSizeX &&
                   PixelSizeY == other.PixelSizeY &&
                   PixelSizeAngle == other.PixelSizeAngle &&
                   BinTimes == other.BinTimes &&
                   GainPath == other.GainPath &&
                   DoAverage == other.DoAverage &&
                   DoStack == other.DoStack &&
                   DoDeconv == other.DoDeconv &&
                   StackGroupSize == other.StackGroupSize &&
                   SkipFirstN == other.SkipFirstN &&
                   SkipLastN == other.SkipLastN &&
                   DosePerAngstromFrame == other.DosePerAngstromFrame;
        }

        public static bool operator ==(ProcessingOptionsMovieExport left, ProcessingOptionsMovieExport right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(ProcessingOptionsMovieExport left, ProcessingOptionsMovieExport right)
        {
            return !Equals(left, right);
        }
    }

    public class ProcessingOptionsParticlesExport : ProcessingOptionsBase
    {
        [WarpSerializable]
        public bool DoAverage { get; set; }
        [WarpSerializable]
        public bool DoStack { get; set; }
        [WarpSerializable]
        public int StackGroupSize { get; set; }
        [WarpSerializable]
        public int SkipFirstN { get; set; }
        [WarpSerializable]
        public int SkipLastN { get; set; }
        [WarpSerializable]
        public decimal DosePerAngstromFrame { get; set; }
    }
}
